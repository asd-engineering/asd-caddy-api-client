// Code generated by tygo. DO NOT EDIT.

//////////
// source: admin.go

/**
 * AdminConfig configures Caddy's API endpoint, which is used
 * to manage Caddy while it is running.
 */
export interface AdminConfig {
  /**
   * If true, the admin endpoint will be completely disabled.
   * Note that this makes any runtime changes to the config
   * impossible, since the interface to do so is through the
   * admin endpoint.
   */
  disabled?: boolean;
  /**
   * The address to which the admin endpoint's listener should
   * bind itself. Can be any single network address that can be
   * parsed by Caddy. Accepts placeholders.
   * Default: the value of the `CADDY_ADMIN` environment variable,
   * or `localhost:2019` otherwise.
   * Remember: When changing this value through a config reload,
   * be sure to use the `--address` CLI flag to specify the current
   * admin address if the currently-running admin endpoint is not
   * the default address.
   */
  listen?: string;
  /**
   * If true, CORS headers will be emitted, and requests to the
   * API will be rejected if their `Host` and `Origin` headers
   * do not match the expected value(s). Use `origins` to
   * customize which origins/hosts are allowed. If `origins` is
   * not set, the listen address is the only value allowed by
   * default. Enforced only on local (plaintext) endpoint.
   */
  enforce_origin?: boolean;
  /**
   * The list of allowed origins/hosts for API requests. Only needed
   * if accessing the admin endpoint from a host different from the
   * socket's network interface or if `enforce_origin` is true. If not
   * set, the listener address will be the default value. If set but
   * empty, no origins will be allowed. Enforced only on local
   * (plaintext) endpoint.
   */
  origins?: string[];
  /**
   * Options pertaining to configuration management.
   */
  config?: ConfigSettings;
  /**
   * Options that establish this server's identity. Identity refers to
   * credentials which can be used to uniquely identify and authenticate
   * this server instance. This is required if remote administration is
   * enabled (but does not require remote administration to be enabled).
   * Default: no identity management.
   */
  identity?: IdentityConfig;
  /**
   * Options pertaining to remote administration. By default, remote
   * administration is disabled. If enabled, identity management must
   * also be configured, as that is how the endpoint is secured.
   * See the neighboring "identity" object.
   * EXPERIMENTAL: This feature is subject to change.
   */
  remote?: RemoteAdmin;
}
/**
 * ConfigSettings configures the management of configuration.
 */
export interface ConfigSettings {
  /**
   * Whether to keep a copy of the active config on disk. Default is true.
   * Note that "pulled" dynamic configs (using the neighboring "load" module)
   * are not persisted; only configs that are pushed to Caddy get persisted.
   */
  persist?: boolean;
  /**
   * Loads a new configuration. This is helpful if your configs are
   * managed elsewhere and you want Caddy to pull its config dynamically
   * when it starts. The pulled config completely replaces the current
   * one, just like any other config load. It is an error if a pulled
   * config is configured to pull another config without a load_delay,
   * as this creates a tight loop.
   * EXPERIMENTAL: Subject to change.
   */
  load?: unknown;
  /**
   * The duration after which to load config. If set, config will be pulled
   * from the config loader after this duration. A delay is required if a
   * dynamically-loaded config is configured to load yet another config. To
   * load configs on a regular interval, ensure this value is set the same
   * on all loaded configs; it can also be variable if needed, and to stop
   * the loop, simply remove dynamic config loading from the next-loaded
   * config.
   * EXPERIMENTAL: Subject to change.
   */
  load_delay?: Duration;
}
/**
 * IdentityConfig configures management of this server's identity. An identity
 * consists of credentials that uniquely verify this instance; for example,
 * TLS certificates (public + private key pairs).
 */
export interface IdentityConfig {
  /**
   * List of names or IP addresses which refer to this server.
   * Certificates will be obtained for these identifiers so
   * secure TLS connections can be made using them.
   */
  identifiers?: string[];
  /**
   * Issuers that can provide this admin endpoint its identity
   * certificate(s). Default: ACME issuers configured for
   * ZeroSSL and Let's Encrypt. Be sure to change this if you
   * require credentials for private identifiers.
   */
  issuers?: unknown[];
}
/**
 * RemoteAdmin enables and configures remote administration. If enabled,
 * a secure listener enforcing mutual TLS authentication will be started
 * on a different port from the standard plaintext admin server.
 * This endpoint is secured using identity management, which must be
 * configured separately (because identity management does not depend
 * on remote administration). See the admin/identity config struct.
 * EXPERIMENTAL: Subject to change.
 */
export interface RemoteAdmin {
  /**
   * The address on which to start the secure listener. Accepts placeholders.
   * Default: :2021
   */
  listen?: string;
  /**
   * List of access controls for this secure admin endpoint.
   * This configures TLS mutual authentication (i.e. authorized
   * client certificates), but also application-layer permissions
   * like which paths and methods each identity is authorized for.
   */
  access_control?: (AdminAccess | undefined)[];
}
/**
 * AdminAccess specifies what permissions an identity or group
 * of identities are granted.
 */
export interface AdminAccess {
  /**
   * Base64-encoded DER certificates containing public keys to accept.
   * (The contents of PEM certificate blocks are base64-encoded DER.)
   * Any of these public keys can appear in any part of a verified chain.
   */
  public_keys?: string[];
  /**
   * Limits what the associated identities are allowed to do.
   * If unspecified, all permissions are granted.
   */
  permissions?: AdminPermissions[];
}
/**
 * AdminPermissions specifies what kinds of requests are allowed
 * to be made to the admin endpoint.
 */
export interface AdminPermissions {
  /**
   * The API paths allowed. Paths are simple prefix matches.
   * Any subpath of the specified paths will be allowed.
   */
  paths?: string[];
  /**
   * The HTTP methods allowed for the given paths.
   */
  methods?: string[];
}
/**
 * AdminRouter is a type which can return routes for the admin API.
 */
export type AdminRouter = any;
/**
 * AdminRoute represents a route for the admin endpoint.
 */
export interface AdminRoute {
  Pattern: string;
  Handler: AdminHandler;
}
/**
 * AdminHandler is like http.Handler except ServeHTTP may return an error.
 * If any handler encounters an error, it should be returned for proper
 * handling.
 */
export type AdminHandler = any;
/**
 * AdminHandlerFunc is a convenience type like http.HandlerFunc.
 */
export type AdminHandlerFunc = any;
/**
 * APIError is a structured error that every API
 * handler should return for consistency in logging
 * and client responses. If Message is unset, then
 * Err.Error() will be serialized in its place.
 */
export interface APIError {
  error: string;
}

//////////
// source: caddy.go

/**
 * Config is the top (or beginning) of the Caddy configuration structure.
 * Caddy config is expressed natively as a JSON document. If you prefer
 * not to work with JSON directly, there are [many config adapters](/docs/config-adapters)
 * available that can convert various inputs into Caddy JSON.
 * Many parts of this config are extensible through the use of Caddy modules.
 * Fields which have a json.RawMessage type and which appear as dots (•••) in
 * the online docs can be fulfilled by modules in a certain module
 * namespace. The docs show which modules can be used in a given place.
 * Whenever a module is used, its name must be given either inline as part of
 * the module, or as the key to the module's value. The docs will make it clear
 * which to use.
 * Generally, all config settings are optional, as it is Caddy convention to
 * have good, documented default values. If a parameter is required, the docs
 * should say so.
 * Go programs which are directly building a Config struct value should take
 * care to populate the JSON-encodable fields of the struct (i.e. the fields
 * with `json` struct tags) if employing the module lifecycle (e.g. Provision
 * method calls).
 */
export interface Config {
  admin?: AdminConfig;
  logging?: Logging;
  /**
   * StorageRaw is a storage module that defines how/where Caddy
   * stores assets (such as TLS certificates). The default storage
   * module is `caddy.storage.file_system` (the local file system),
   * and the default path
   * [depends on the OS and environment](/docs/conventions#data-directory).
   */
  storage?: unknown;
  /**
   * AppsRaw are the apps that Caddy will load and run. The
   * app module name is the key, and the app's config is the
   * associated value.
   */
  apps?: ModuleMap;
}
/**
 * App is a thing that Caddy runs.
 */
export type App = any;
/**
 * ConfigLoader is a type that can load a Caddy config. If
 * the return value is non-nil, it must be valid Caddy JSON;
 * if nil or with non-nil error, it is considered to be a
 * no-op load and may be retried later.
 */
export type ConfigLoader = any;
/**
 * Duration can be an integer or a string. An integer is
 * interpreted as nanoseconds. If a string, it is a Go
 * time.Duration value such as `300ms`, `1.5h`, or `2h45m`;
 * valid units are `ns`, `us`/`µs`, `ms`, `s`, `m`, `h`, and `d`.
 */
export type Duration = number | string;
/**
 * Event represents something that has happened or is happening.
 * An Event value is not synchronized, so it should be copied if
 * being used in goroutines.
 * EXPERIMENTAL: Events are subject to change.
 */
export interface Event {
  /**
   * If non-nil, the event has been aborted, meaning
   * propagation has stopped to other handlers and
   * the code should stop what it was doing. Emitters
   * may choose to use this as a signal to adjust their
   * code path appropriately.
   */
  Aborted: Error;
  /**
   * The data associated with the event. Usually the
   * original emitter will be the only one to set or
   * change these values, but the field is exported
   * so handlers can have full access if needed.
   * However, this map is not synchronized, so
   * handlers must not use this map directly in new
   * goroutines; instead, copy the map to use it in a
   * goroutine. Data may be nil.
   */
  Data: { [key: string]: any };
}
/**
 * CloudEvent is a JSON-serializable structure that
 * is compatible with the CloudEvents specification.
 * See https://cloudevents.io.
 * EXPERIMENTAL: Subject to change.
 */
export interface CloudEvent {
  id: string;
  source: string;
  specversion: string;
  type: string;
  time: string;
  datacontenttype?: string;
  data?: unknown;
}
/**
 * CtxKey is a value type for use with context.WithValue.
 */
export type CtxKey = string;
/**
 * ImportPath is the package import path for Caddy core.
 * This identifier may be removed in the future.
 */
export const ImportPath = "github.com/caddyserver/caddy/v2";

//////////
// source: context.go

/**
 * Context is a type which defines the lifetime of modules that
 * are loaded and provides access to the parent configuration
 * that spawned the modules which are loaded. It should be used
 * with care and wrapped with derivation functions from the
 * standard context package only if you don't need the Caddy
 * specific features. These contexts are canceled when the
 * lifetime of the modules loaded from it is over.
 * Use NewContext() to get a valid value (but most modules will
 * not actually need to do this).
 */
export interface Context {
  Context: unknown;
}

//////////
// source: filesystem.go

export type FileSystems = any;

//////////
// source: listen_unix.go

//////////
// source: listen_unix_setopt.go

//////////
// source: listeners.go

/**
 * NetworkAddress represents one or more network addresses.
 * It contains the individual components for a parsed network
 * address of the form accepted by ParseNetworkAddress().
 */
export interface NetworkAddress {
  /**
   * Should be a network value accepted by Go's net package or
   * by a plugin providing a listener for that network type.
   */
  Network: string;
  /**
   * The "main" part of the network address is the host, which
   * often takes the form of a hostname, DNS name, IP address,
   * or socket path.
   */
  Host: string;
  /**
   * For addresses that contain a port, ranges are given by
   * [StartPort, EndPort]; i.e. for a single port, StartPort
   * and EndPort are the same. For no port, they are 0.
   */
  StartPort: number /* uint */;
  EndPort: number /* uint */;
}
/**
 * ListenerFunc is a function that can return a listener given a network and address.
 * The listeners must be capable of overlapping: with Caddy, new configs are loaded
 * before old ones are unloaded, so listeners may overlap briefly if the configs
 * both need the same listener. EXPERIMENTAL and subject to change.
 */
export type ListenerFunc = any;
/**
 * ListenerWrapper is a type that wraps a listener
 * so it can modify the input listener's methods.
 * Modules that implement this interface are found
 * in the caddy.listeners namespace. Usually, to
 * wrap a listener, you will define your own struct
 * type that embeds the input listener, then
 * implement your own methods that you want to wrap,
 * calling the underlying listener's methods where
 * appropriate.
 */
export type ListenerWrapper = any;

//////////
// source: logging.go

/**
 * Logging facilitates logging within Caddy. The default log is
 * called "default" and you can customize it. You can also define
 * additional logs.
 * By default, all logs at INFO level and higher are written to
 * standard error ("stderr" writer) in a human-readable format
 * ("console" encoder if stdout is an interactive terminal, "json"
 * encoder otherwise).
 * All defined logs accept all log entries by default, but you
 * can filter by level and module/logger names. A logger's name
 * is the same as the module's name, but a module may append to
 * logger names for more specificity. For example, you can
 * filter logs emitted only by HTTP handlers using the name
 * "http.handlers", because all HTTP handler module names have
 * that prefix.
 * Caddy logs (except the sink) are zero-allocation, so they are
 * very high-performing in terms of memory and CPU time. Enabling
 * sampling can further increase throughput on extremely high-load
 * servers.
 */
export interface Logging {
  /**
   * Sink is the destination for all unstructured logs emitted
   * from Go's standard library logger. These logs are common
   * in dependencies that are not designed specifically for use
   * in Caddy. Because it is global and unstructured, the sink
   * lacks most advanced features and customizations.
   */
  sink?: SinkLog;
  /**
   * Logs are your logs, keyed by an arbitrary name of your
   * choosing. The default log can be customized by defining
   * a log called "default". You can further define other logs
   * and filter what kinds of entries they accept.
   */
  logs?: { [key: string]: CustomLog | undefined };
}
/**
 * WriterOpener is a module that can open a log writer.
 * It can return a human-readable string representation
 * of itself so that operators can understand where
 * the logs are going.
 */
export type WriterOpener = unknown;
/**
 * BaseLog contains the common logging parameters for logging.
 */
export interface BaseLog {
  /**
   * The module that writes out log entries for the sink.
   */
  writer?: unknown;
  /**
   * The encoder is how the log entries are formatted or encoded.
   */
  encoder?: unknown;
  /**
   * Tees entries through a zap.Core module which can extract
   * log entry metadata and fields for further processing.
   */
  core?: unknown;
  /**
   * Level is the minimum level to emit, and is inclusive.
   * Possible levels: DEBUG, INFO, WARN, ERROR, PANIC, and FATAL
   */
  level?: string;
  /**
   * Sampling configures log entry sampling. If enabled,
   * only some log entries will be emitted. This is useful
   * for improving performance on extremely high-pressure
   * servers.
   */
  sampling?: LogSampling;
  /**
   * If true, the log entry will include the caller's
   * file name and line number. Default off.
   */
  with_caller?: boolean;
  /**
   * If non-zero, and `with_caller` is true, this many
   * stack frames will be skipped when determining the
   * caller. Default 0.
   */
  with_caller_skip?: number /* int */;
  /**
   * If not empty, the log entry will include a stack trace
   * for all logs at the given level or higher. See `level`
   * for possible values. Default off.
   */
  with_stacktrace?: string;
}
/**
 * SinkLog configures the default Go standard library
 * global logger in the log package. This is necessary because
 * module dependencies which are not built specifically for
 * Caddy will use the standard logger. This is also known as
 * the "sink" logger.
 */
export interface SinkLog {
  BaseLog: BaseLog;
}
/**
 * CustomLog represents a custom logger configuration.
 * By default, a log will emit all log entries. Some entries
 * will be skipped if sampling is enabled. Further, the Include
 * and Exclude parameters define which loggers (by name) are
 * allowed or rejected from emitting in this log. If both Include
 * and Exclude are populated, their values must be mutually
 * exclusive, and longer namespaces have priority. If neither
 * are populated, all logs are emitted.
 */
export interface CustomLog {
  BaseLog: BaseLog;
  /**
   * Include defines the names of loggers to emit in this
   * log. For example, to include only logs emitted by the
   * admin API, you would include "admin.api".
   */
  include?: string[];
  /**
   * Exclude defines the names of loggers that should be
   * skipped by this log. For example, to exclude only
   * HTTP access logs, you would exclude "http.log.access".
   */
  exclude?: string[];
}
/**
 * LogSampling configures log entry sampling.
 */
export interface LogSampling {
  /**
   * The window over which to conduct sampling.
   */
  interval?: number | string;
  /**
   * Log this many entries within a given level and
   * message for each interval.
   */
  first?: number /* int */;
  /**
   * If more entries with the same level and message
   * are seen during the same interval, keep one in
   * this many entries until the end of the interval.
   */
  thereafter?: number /* int */;
}
/**
 * StdoutWriter writes logs to standard out.
 */
export interface StdoutWriter {}
/**
 * StderrWriter writes logs to standard error.
 */
export interface StderrWriter {}
/**
 * DiscardWriter discards all writes.
 */
export interface DiscardWriter {}
/**
 * ConfiguresFormatterDefault is an optional interface that
 * encoder modules can implement to configure the default
 * format of their encoder. This is useful for encoders
 * which nest an encoder, that needs to know the writer
 * in order to determine the correct default.
 */
export type ConfiguresFormatterDefault = any;
export const DefaultLoggerName = "default";

//////////
// source: metrics.go

//////////
// source: modules.go

/**
 * Module is a type that is used as a Caddy module. In
 * addition to this interface, most modules will implement
 * some interface expected by their host module in order
 * to be useful. To learn which interface(s) to implement,
 * see the documentation for the host module. At a bare
 * minimum, this interface, when implemented, only provides
 * the module's ID and constructor function.
 * Modules will often implement additional interfaces
 * including Provisioner, Validator, and CleanerUpper.
 * If a module implements these interfaces, their
 * methods are called during the module's lifespan.
 * When a module is loaded by a host module, the following
 * happens: 1) ModuleInfo.New() is called to get a new
 * instance of the module. 2) The module's configuration is
 * unmarshaled into that instance. 3) If the module is a
 * Provisioner, the Provision() method is called. 4) If the
 * module is a Validator, the Validate() method is called.
 * 5) The module will probably be type-asserted from
 * 'any' to some other, more useful interface expected
 * by the host module. For example, HTTP handler modules are
 * type-asserted as caddyhttp.MiddlewareHandler values.
 * 6) When a module's containing Context is canceled, if it is
 * a CleanerUpper, its Cleanup() method is called.
 */
export type Module = any;
/**
 * ModuleInfo represents a registered Caddy module.
 */
export interface ModuleInfo {
  /**
   * ID is the "full name" of the module. It
   * must be unique and properly namespaced.
   */
  ID: ModuleID;
  /**
   * New returns a pointer to a new, empty
   * instance of the module's type. This
   * method must not have any side-effects,
   * and no other initialization should
   * occur within it. Any initialization
   * of the returned value should be done
   * in a Provision() method (see the
   * Provisioner interface).
   */
  New: any;
}
/**
 * ModuleID is a string that uniquely identifies a Caddy module. A
 * module ID is lightly structured. It consists of dot-separated
 * labels which form a simple hierarchy from left to right. The last
 * label is the module name, and the labels before that constitute
 * the namespace (or scope).
 * Thus, a module ID has the form: <namespace>.<name>
 * An ID with no dot has the empty namespace, which is appropriate
 * for app modules (these are "top-level" modules that Caddy core
 * loads and runs).
 * Module IDs should be lowercase and use underscores (_) instead of
 * spaces.
 * Examples of valid IDs:
 * - http
 * - http.handlers.file_server
 * - caddy.logging.encoders.json
 */
export type ModuleID = string;
/**
 * ModuleMap is a map that can contain multiple modules,
 * where the map key is the module's name. (The namespace
 * is usually read from an associated field's struct tag.)
 * Because the module's name is given as the key in a
 * module map, the name does not have to be given in the
 * json.RawMessage.
 */
export type ModuleMap = { [key: string]: unknown };
/**
 * Provisioner is implemented by modules which may need to perform
 * some additional "setup" steps immediately after being loaded.
 * Provisioning should be fast (imperceptible running time). If
 * any side-effects result in the execution of this function (e.g.
 * creating global state, any other allocations which require
 * garbage collection, opening files, starting goroutines etc.),
 * be sure to clean up properly by implementing the CleanerUpper
 * interface to avoid leaking resources.
 */
export type Provisioner = any;
/**
 * Validator is implemented by modules which can verify that their
 * configurations are valid. This method will be called after
 * Provision() (if implemented). Validation should always be fast
 * (imperceptible running time) and an error must be returned if
 * the module's configuration is invalid.
 */
export type Validator = any;
/**
 * CleanerUpper is implemented by modules which may have side-effects
 * such as opened files, spawned goroutines, or allocated some sort
 * of non-stack state when they were provisioned. This method should
 * deallocate/cleanup those resources to prevent memory leaks. Cleanup
 * should be fast and efficient. Cleanup should work even if Provision
 * returns an error, to allow cleaning up from partial provisionings.
 */
export type CleanerUpper = any;
/**
 * ProxyFuncProducer is implemented by modules which produce a
 * function that returns a URL to use as network proxy. Modules
 * in the namespace `caddy.network_proxy` must implement this
 * interface.
 */
export type ProxyFuncProducer = any;

//////////
// source: replacer.go

/**
 * Replacer can replace values in strings.
 * A default/empty Replacer is not valid;
 * use NewReplacer to make one.
 */
export interface Replacer {}
/**
 * ReplacerFunc is a function that returns a replacement for the
 * given key along with true if the function is able to service
 * that key (even if the value is blank). If the function does
 * not recognize the key, false should be returned.
 */
export type ReplacerFunc = any;
/**
 * ReplacementFunc is a function that is called when a
 * replacement is being performed. It receives the
 * variable (i.e. placeholder name) and the value that
 * will be the replacement, and returns the value that
 * will actually be the replacement, or an error. Note
 * that errors are sometimes ignored by replacers.
 */
export type ReplacementFunc = any;
/**
 * ReplacerCtxKey is the context key for a replacer.
 */
export const ReplacerCtxKey: CtxKey = "replacer";

//////////
// source: sigtrap.go

/**
 * Exit codes. Generally, you should NOT
 * automatically restart the process if the
 * exit code is ExitCodeFailedStartup (1).
 */
export const ExitCodeSuccess = 0;
/**
 * Exit codes. Generally, you should NOT
 * automatically restart the process if the
 * exit code is ExitCodeFailedStartup (1).
 */
export const ExitCodeFailedStartup = 1;
/**
 * Exit codes. Generally, you should NOT
 * automatically restart the process if the
 * exit code is ExitCodeFailedStartup (1).
 */
export const ExitCodeForceQuit = 2;
/**
 * Exit codes. Generally, you should NOT
 * automatically restart the process if the
 * exit code is ExitCodeFailedStartup (1).
 */
export const ExitCodeFailedQuit = 3;

//////////
// source: storage.go

/**
 * StorageConverter is a type that can convert itself
 * to a valid, usable certmagic.Storage value. (The
 * value might be short-lived.) This interface allows
 * us to adapt any CertMagic storage implementation
 * into a consistent API for Caddy configuration.
 */
export type StorageConverter = any;

//////////
// source: usagepool.go

/**
 * UsagePool is a thread-safe map that pools values
 * based on usage (reference counting). Values are
 * only inserted if they do not already exist. There
 * are two ways to add values to the pool:
 *  1. LoadOrStore will increment usage and store the
 *     value immediately if it does not already exist.
 *  2. LoadOrNew will atomically check for existence
 *     and construct the value immediately if it does
 *     not already exist, or increment the usage
 *     otherwise, then store that value in the pool.
 *     When the constructed value is finally deleted
 *     from the pool (when its usage reaches 0), it
 *     will be cleaned up by calling Destruct().
 * The use of LoadOrNew allows values to be created
 * and reused and finally cleaned up only once, even
 * though they may have many references throughout
 * their lifespan. This is helpful, for example, when
 * sharing thread-safe io.Writers that you only want
 * to open and close once.
 * There is no way to overwrite existing keys in the
 * pool without first deleting it as many times as it
 * was stored. Deleting too many times will panic.
 * The implementation does not use a sync.Pool because
 * UsagePool needs additional atomicity to run the
 * constructor functions when creating a new value when
 * LoadOrNew is used. (We could probably use sync.Pool
 * but we'd still have to layer our own additional locks
 * on top.)
 * An empty UsagePool is NOT safe to use; always call
 * NewUsagePool() to make a new one.
 */
export interface UsagePool {
  RWMutex: unknown;
}
/**
 * Constructor is a function that returns a new value
 * that can destruct itself when it is no longer needed.
 */
export type Constructor = any;
/**
 * Destructor is a value that can clean itself up when
 * it is deallocated.
 */
export type Destructor = any;
