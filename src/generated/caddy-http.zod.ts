// Generated by ts-to-zod
import { z } from "zod";

export const metricsSchema = z.object({
  per_host: z.boolean().optional(),
  allow_catch_all_hosts: z.boolean().optional(),
});

export const autoHttpsConfigSchema = z.object({
  disable: z.boolean().optional(),
  disable_redirects: z.boolean().optional(),
  disable_certificates: z.boolean().optional(),
  skip: z.array(z.string()).optional(),
  skip_certificates: z.array(z.string()).optional(),
  ignore_loaded_certificates: z.boolean().optional(),
});

export const requestMatcherSchema = z.any();

export const requestMatcherWithErrorSchema = z.any();

export const handlerSchema = z.any();

export const handlerFuncSchema = z.any();

export const middlewareSchema = z.any();

export const middlewareHandlerSchema = z.any();

export const responseMatcherSchema = z.object({
  status_code: z.array(z.number()).optional(),
  headers: z.any().optional(),
});

export const weakStringSchema = z.string();

export const matchExpressionSchema = z.object({
  expr: z.string().optional(),
  name: z.string().optional(),
});

export const celLibraryProducerSchema = z.any();

export const celMatcherFactorySchema = z.any();

export const celMatcherWithErrorFactorySchema = z.any();

export const httpRedirectListenerWrapperSchema = z.object({
  max_header_bytes: z.number().optional(),
});

export const invokeSchema = z.object({
  name: z.string().optional(),
});

export const matchRemoteIpSchema = z.object({
  ranges: z.array(z.string()).optional(),
});

export const matchClientIpSchema = z.object({
  ranges: z.array(z.string()).optional(),
});

export const ipRangeSourceSchema = z.any();

export const staticIpRangeSchema = z.object({
  ranges: z.array(z.string()).optional(),
});

export const stringArraySchema = z.array(z.string());

export const extraLogFieldsSchema = z.object({});

export const loggableHttpRequestSchema = z.object({
  Request: z.any().optional(),
  ShouldLogCredentials: z.boolean(),
});

export const loggableHttpHeaderSchema = z.object({
  Header: z.any(),
  ShouldLogCredentials: z.boolean(),
});

export const loggableStringArraySchema = z.array(z.string());

export const loggableTlsConnStateSchema = z.any();

export const matchHostSchema = z.array(z.string());

export const matchPathSchema = z.array(z.string());

export const matchRegexpSchema = z.object({
  name: z.string().optional(),
  pattern: z.string(),
});

export const matchMethodSchema = z.array(z.string());

export const matchQuerySchema = z.any();

export const matchHeaderSchema = z.any();

export const matchHeaderReSchema = z.record(
  z.string(),
  z.union([matchRegexpSchema, z.undefined()])
);

export const matchProtocolSchema = z.string();

export const matchTlsSchema = z.object({
  handshake_complete: z.boolean().optional(),
});

export const matchNotSchema = z.object({});

export const responseWriterWrapperSchema = z.object({
  ResponseWriter: z.any(),
});

export const responseRecorderSchema = z.any();

export const shouldBufferFuncSchema = z.any();

export const matcherSetSchema = z.array(z.any());

export const matcherSetsSchema = z.array(matcherSetSchema);

export const serverLogConfigSchema = z.object({
  default_logger_name: z.string().optional(),
  logger_names: z.record(z.string(), stringArraySchema).optional(),
  skip_hosts: z.array(z.string()).optional(),
  skip_unmapped_hosts: z.boolean().optional(),
  should_log_credentials: z.boolean().optional(),
  trace: z.boolean().optional(),
});

export const staticErrorSchema = z.object({
  error: z.string().optional(),
  status_code: weakStringSchema.optional(),
});

export const staticResponseSchema = z.object({
  status_code: weakStringSchema.optional(),
  headers: z.any().optional(),
  body: z.string().optional(),
  close: z.boolean().optional(),
  abort: z.boolean().optional(),
});

export const varsMiddlewareSchema = z.record(z.string(), z.any());

export const varsMatcherSchema = z.record(z.string(), z.array(z.string()));

export const matchVarsReSchema = z.record(z.string(), z.union([matchRegexpSchema, z.undefined()]));

const durationSchema = z.any();

const moduleMapSchema = z.any();

const tlsConnectionPolicySchema = z.any();

export const matchPathReSchema = z.object({
  MatchRegexp: matchRegexpSchema,
});

export const rawMatcherSetsSchema = z.array(moduleMapSchema);

export const routeSchema = z.object({
  group: z.string().optional(),
  match: rawMatcherSetsSchema.optional(),
  handle: z.array(z.unknown()).optional(),
  terminal: z.boolean().optional(),
});

export const routeListSchema = z.array(routeSchema);

export const httpErrorConfigSchema = z.object({
  routes: routeListSchema.optional(),
});

export const subrouteSchema = z.object({
  routes: routeListSchema.optional(),
  errors: httpErrorConfigSchema.optional(),
});

export const serverSchema = z.object({
  listen: z.array(z.string()).optional(),
  listener_wrappers: z.array(z.unknown()).optional(),
  read_timeout: durationSchema.optional(),
  read_header_timeout: durationSchema.optional(),
  write_timeout: durationSchema.optional(),
  idle_timeout: durationSchema.optional(),
  keepalive_interval: durationSchema.optional(),
  keepalive_idle: durationSchema.optional(),
  keepalive_count: z.number().optional(),
  max_header_bytes: z.number().optional(),
  enable_full_duplex: z.boolean().optional(),
  routes: routeListSchema.optional(),
  errors: httpErrorConfigSchema.optional(),
  named_routes: z.record(z.string(), z.union([routeSchema, z.undefined()])).optional(),
  tls_connection_policies: z.array(tlsConnectionPolicySchema).optional(),
  automatic_https: autoHttpsConfigSchema.optional(),
  strict_sni_host: z.boolean().optional(),
  trusted_proxies: z.unknown().optional(),
  client_ip_headers: z.array(z.string()).optional(),
  trusted_proxies_strict: z.number().optional(),
  trusted_proxies_unix: z.boolean().optional(),
  logs: serverLogConfigSchema.optional(),
  protocols: z.array(z.string()).optional(),
  listen_protocols: z.array(z.array(z.string())).optional(),
  metrics: metricsSchema.optional(),
});

export const responseHandlerSchema = z.object({
  match: responseMatcherSchema.optional(),
  status_code: weakStringSchema.optional(),
  routes: routeListSchema.optional(),
});

export const appSchema = z.object({
  http_port: z.number().optional(),
  https_port: z.number().optional(),
  grace_period: durationSchema.optional(),
  shutdown_delay: durationSchema.optional(),
  servers: z.record(z.string(), z.union([serverSchema, z.undefined()])).optional(),
  metrics: metricsSchema.optional(),
});
