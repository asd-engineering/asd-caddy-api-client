// Generated by ts-to-zod
import { z } from "zod";

export const copyResponseHandlerSchema = z.object({
    status_code: z.any().optional()
});

export const copyResponseHeadersHandlerSchema = z.object({
    include: z.array(z.string()).optional(),
    exclude: z.array(z.string()).optional()
});

export const activeHealthChecksSchema = z.object({
    path: z.string().optional(),
    uri: z.string().optional(),
    upstream: z.string().optional(),
    port: z.number().optional(),
    headers: z.any().optional(),
    method: z.string().optional(),
    body: z.string().optional(),
    follow_redirects: z.boolean().optional(),
    interval: z.any().optional(),
    timeout: z.any().optional(),
    passes: z.number().optional(),
    fails: z.number().optional(),
    max_size: z.number().optional(),
    expect_status: z.number().optional(),
    expect_body: z.string().optional()
});

export const passiveHealthChecksSchema = z.object({
    fail_duration: z.any().optional(),
    max_fails: z.number().optional(),
    unhealthy_request_count: z.number().optional(),
    unhealthy_status: z.array(z.number()).optional(),
    unhealthy_latency: z.any().optional()
});

export const circuitBreakerSchema = z.any();

export const upstreamSchema = z.object({
    dial: z.string().optional(),
    max_requests: z.number().optional()
});

export const hostSchema = z.object({});

export const dialInfoSchema = z.object({
    Upstream: upstreamSchema.optional(),
    Network: z.string(),
    Address: z.string(),
    Host: z.string(),
    Port: z.string()
});

export const proxyProtocolInfoSchema = z.object({
    AddrPort: z.any()
});

export const upstreamResolverSchema = z.object({
    addresses: z.array(z.string()).optional()
});

export const tlsConfigSchema = z.object({
    ca: z.unknown().optional(),
    root_ca_pool: z.array(z.string()).optional(),
    root_ca_pem_files: z.array(z.string()).optional(),
    client_certificate_file: z.string().optional(),
    client_certificate_key_file: z.string().optional(),
    client_certificate_automate: z.string().optional(),
    insecure_skip_verify: z.boolean().optional(),
    handshake_timeout: z.any().optional(),
    server_name: z.string().optional(),
    renegotiation: z.string().optional(),
    except_ports: z.array(z.string()).optional(),
    curves: z.array(z.string()).optional()
});

export const keepAliveSchema = z.object({
    enabled: z.boolean().optional(),
    probe_interval: z.any().optional(),
    max_idle_conns: z.number().optional(),
    max_idle_conns_per_host: z.number().optional(),
    idle_timeout: z.any().optional()
});

export const loadBalancingSchema = z.object({
    selection_policy: z.unknown().optional(),
    retries: z.number().optional(),
    try_duration: z.any().optional(),
    try_interval: z.any().optional(),
    retry_match: z.any().optional()
});

export const healthChecksSchema = z.object({
    active: activeHealthChecksSchema.optional(),
    passive: passiveHealthChecksSchema.optional()
});

export const upstreamPoolSchema = z.array(z.union([upstreamSchema, z.undefined()]));

export const selectorSchema = z.any();

export const upstreamSourceSchema = z.any();

export const dialErrorSchema = z.object({});

export const tlsTransportSchema = z.any();

export const h2CTransportSchema = z.any();

export const proxyProtocolTransportSchema = z.any();

export const healthCheckSchemeOverriderTransportSchema = z.any();

export const bufferedTransportSchema = z.any();

export const randomSelectionSchema = z.object({});

export const weightedRoundRobinSelectionSchema = z.object({
    weights: z.array(z.number()).optional()
});

export const randomChoiceSelectionSchema = z.object({
    choose: z.number().optional()
});

export const leastConnSelectionSchema = z.object({});

export const roundRobinSelectionSchema = z.object({});

export const firstSelectionSchema = z.object({});

export const ipHashSelectionSchema = z.object({});

export const clientIpHashSelectionSchema = z.object({});

export const uriHashSelectionSchema = z.object({});

export const queryHashSelectionSchema = z.object({
    key: z.string().optional(),
    fallback: z.unknown().optional()
});

export const headerHashSelectionSchema = z.object({
    field: z.string().optional(),
    fallback: z.unknown().optional()
});

export const cookieHashSelectionSchema = z.object({
    name: z.string().optional(),
    secret: z.string().optional(),
    max_age: z.any().optional(),
    fallback: z.unknown().optional()
});

export const srvUpstreamsSchema = z.object({
    service: z.string().optional(),
    proto: z.string().optional(),
    name: z.string().optional(),
    refresh: z.any().optional(),
    grace_period: z.any().optional(),
    resolver: upstreamResolverSchema.optional(),
    dial_timeout: z.any().optional(),
    dial_fallback_delay: z.any().optional()
});

export const ipVersionsSchema = z.object({
    ipv4: z.boolean().optional(),
    ipv6: z.boolean().optional()
});

export const aUpstreamsSchema = z.object({
    name: z.string().optional(),
    port: z.string().optional(),
    refresh: z.any().optional(),
    resolver: upstreamResolverSchema.optional(),
    dial_timeout: z.any().optional(),
    dial_fallback_delay: z.any().optional(),
    versions: ipVersionsSchema.optional()
});

export const multiUpstreamsSchema = z.object({
    sources: z.array(z.unknown()).optional()
});

export const httpTransportSchema = z.object({
    resolver: upstreamResolverSchema.optional(),
    tls: tlsConfigSchema.optional(),
    keep_alive: keepAliveSchema.optional(),
    compression: z.boolean().optional(),
    max_conns_per_host: z.number().optional(),
    proxy_protocol: z.string().optional(),
    forward_proxy_url: z.string().optional(),
    dial_timeout: z.any().optional(),
    dial_fallback_delay: z.any().optional(),
    response_header_timeout: z.any().optional(),
    expect_continue_timeout: z.any().optional(),
    max_response_header_size: z.number().optional(),
    write_buffer_size: z.number().optional(),
    read_buffer_size: z.number().optional(),
    read_timeout: z.any().optional(),
    write_timeout: z.any().optional(),
    versions: z.array(z.string()).optional(),
    local_address: z.string().optional(),
    network_proxy: z.unknown().optional()
});

export const handlerSchema = z.object({
    transport: z.unknown().optional(),
    circuit_breaker: z.unknown().optional(),
    load_balancing: loadBalancingSchema.optional(),
    health_checks: healthChecksSchema.optional(),
    upstreams: upstreamPoolSchema.optional(),
    dynamic_upstreams: z.unknown().optional(),
    flush_interval: z.any().optional(),
    trusted_proxies: z.array(z.string()).optional(),
    headers: z.any().optional(),
    request_buffers: z.number().optional(),
    response_buffers: z.number().optional(),
    stream_timeout: z.any().optional(),
    stream_close_delay: z.any().optional(),
    rewrite: z.any().optional(),
    handle_response: z.array(z.any()).optional(),
    verbose_logs: z.boolean().optional()
});
