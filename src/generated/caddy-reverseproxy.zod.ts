// Generated by ts-to-zod
import { z } from "zod";

export const copyResponseHeadersHandlerSchema = z.object({
  include: z.array(z.string()).optional(),
  exclude: z.array(z.string()).optional(),
});

export const circuitBreakerSchema = z.any();

export const upstreamSchema = z.object({
  dial: z.string().optional(),
  max_requests: z.number().optional(),
});

export const hostSchema = z.object({});

export const dialInfoSchema = z.object({
  Upstream: upstreamSchema.optional(),
  Network: z.string(),
  Address: z.string(),
  Host: z.string(),
  Port: z.string(),
});

export const proxyProtocolInfoSchema = z.object({
  AddrPort: z.string(),
});

export const upstreamResolverSchema = z.object({
  addresses: z.array(z.string()).optional(),
});

export const upstreamPoolSchema = z.array(z.union([upstreamSchema, z.undefined()]));

export const selectorSchema = z.any();

export const upstreamSourceSchema = z.any();

export const dialErrorSchema = z.object({});

export const tlsTransportSchema = z.any();

export const h2CTransportSchema = z.any();

export const proxyProtocolTransportSchema = z.any();

export const healthCheckSchemeOverriderTransportSchema = z.any();

export const bufferedTransportSchema = z.any();

export const randomSelectionSchema = z.object({});

export const weightedRoundRobinSelectionSchema = z.object({
  weights: z.array(z.number()).optional(),
});

export const randomChoiceSelectionSchema = z.object({
  choose: z.number().optional(),
});

export const leastConnSelectionSchema = z.object({});

export const roundRobinSelectionSchema = z.object({});

export const firstSelectionSchema = z.object({});

export const ipHashSelectionSchema = z.object({});

export const clientIpHashSelectionSchema = z.object({});

export const uriHashSelectionSchema = z.object({});

export const queryHashSelectionSchema = z.object({
  key: z.string().optional(),
  fallback: z.unknown().optional(),
});

export const headerHashSelectionSchema = z.object({
  field: z.string().optional(),
  fallback: z.unknown().optional(),
});

export const ipVersionsSchema = z.object({
  ipv4: z.boolean().optional(),
  ipv6: z.boolean().optional(),
});

export const multiUpstreamsSchema = z.object({
  sources: z.array(z.unknown()).optional(),
});

const weakStringSchema = z.any();

const durationSchema = z.any();

const headersHandlerSchema = z.any();

const rewriteSchema = z.any();

const responseHandlerSchema = z.any();

const rawMatcherSetsSchema = z.any();

export const copyResponseHandlerSchema = z.object({
  status_code: weakStringSchema.optional(),
});

export const activeHealthChecksSchema = z.object({
  path: z.string().optional(),
  uri: z.string().optional(),
  upstream: z.string().optional(),
  port: z.number().optional(),
  headers: z.record(z.string(), z.array(z.string())).optional(),
  method: z.string().optional(),
  body: z.string().optional(),
  follow_redirects: z.boolean().optional(),
  interval: durationSchema.optional(),
  timeout: durationSchema.optional(),
  passes: z.number().optional(),
  fails: z.number().optional(),
  max_size: z.number().optional(),
  expect_status: z.number().optional(),
  expect_body: z.string().optional(),
});

export const passiveHealthChecksSchema = z.object({
  fail_duration: durationSchema.optional(),
  max_fails: z.number().optional(),
  unhealthy_request_count: z.number().optional(),
  unhealthy_status: z.array(z.number()).optional(),
  unhealthy_latency: durationSchema.optional(),
});

export const tlsConfigSchema = z.object({
  ca: z.unknown().optional(),
  root_ca_pool: z.array(z.string()).optional(),
  root_ca_pem_files: z.array(z.string()).optional(),
  client_certificate_file: z.string().optional(),
  client_certificate_key_file: z.string().optional(),
  client_certificate_automate: z.string().optional(),
  insecure_skip_verify: z.boolean().optional(),
  handshake_timeout: durationSchema.optional(),
  server_name: z.string().optional(),
  renegotiation: z.string().optional(),
  except_ports: z.array(z.string()).optional(),
  curves: z.array(z.string()).optional(),
});

export const keepAliveSchema = z.object({
  enabled: z.boolean().optional(),
  probe_interval: durationSchema.optional(),
  max_idle_conns: z.number().optional(),
  max_idle_conns_per_host: z.number().optional(),
  idle_timeout: durationSchema.optional(),
});

export const loadBalancingSchema = z.object({
  selection_policy: z.unknown().optional(),
  retries: z.number().optional(),
  try_duration: durationSchema.optional(),
  try_interval: durationSchema.optional(),
  retry_match: rawMatcherSetsSchema.optional(),
});

export const healthChecksSchema = z.object({
  active: activeHealthChecksSchema.optional(),
  passive: passiveHealthChecksSchema.optional(),
});

export const cookieHashSelectionSchema = z.object({
  name: z.string().optional(),
  secret: z.string().optional(),
  max_age: durationSchema.optional(),
  fallback: z.unknown().optional(),
});

export const srvUpstreamsSchema = z.object({
  service: z.string().optional(),
  proto: z.string().optional(),
  name: z.string().optional(),
  refresh: durationSchema.optional(),
  grace_period: durationSchema.optional(),
  resolver: upstreamResolverSchema.optional(),
  dial_timeout: durationSchema.optional(),
  dial_fallback_delay: durationSchema.optional(),
});

export const aUpstreamsSchema = z.object({
  name: z.string().optional(),
  port: z.string().optional(),
  refresh: durationSchema.optional(),
  resolver: upstreamResolverSchema.optional(),
  dial_timeout: durationSchema.optional(),
  dial_fallback_delay: durationSchema.optional(),
  versions: ipVersionsSchema.optional(),
});

export const httpTransportSchema = z.object({
  resolver: upstreamResolverSchema.optional(),
  tls: tlsConfigSchema.optional(),
  keep_alive: keepAliveSchema.optional(),
  compression: z.boolean().optional(),
  max_conns_per_host: z.number().optional(),
  proxy_protocol: z.string().optional(),
  forward_proxy_url: z.string().optional(),
  dial_timeout: durationSchema.optional(),
  dial_fallback_delay: durationSchema.optional(),
  response_header_timeout: durationSchema.optional(),
  expect_continue_timeout: durationSchema.optional(),
  max_response_header_size: z.number().optional(),
  write_buffer_size: z.number().optional(),
  read_buffer_size: z.number().optional(),
  read_timeout: durationSchema.optional(),
  write_timeout: durationSchema.optional(),
  versions: z.array(z.string()).optional(),
  local_address: z.string().optional(),
  network_proxy: z.unknown().optional(),
});

export const handlerSchema = z.object({
  transport: z.unknown().optional(),
  circuit_breaker: z.unknown().optional(),
  load_balancing: loadBalancingSchema.optional(),
  health_checks: healthChecksSchema.optional(),
  upstreams: upstreamPoolSchema.optional(),
  dynamic_upstreams: z.unknown().optional(),
  flush_interval: durationSchema.optional(),
  trusted_proxies: z.array(z.string()).optional(),
  headers: headersHandlerSchema.optional(),
  request_buffers: z.number().optional(),
  response_buffers: z.number().optional(),
  stream_timeout: durationSchema.optional(),
  stream_close_delay: durationSchema.optional(),
  rewrite: rewriteSchema.optional(),
  handle_response: z.array(responseHandlerSchema).optional(),
  verbose_logs: z.boolean().optional(),
});
