// Code generated by tygo. DO NOT EDIT.

import type { Duration, ModuleMap } from "./caddy-core";
import type { ConnectionPolicy as TlsConnectionPolicy } from "./caddy-tls";

//////////
// source: app.go

/**
 * App is a robust, production-ready HTTP server.
 * HTTPS is enabled by default if host matchers with qualifying names are used
 * in any of routes; certificates are automatically provisioned and renewed.
 * Additionally, automatic HTTPS will also enable HTTPS for servers that listen
 * only on the HTTPS port but which do not have any TLS connection policies
 * defined by adding a good, default TLS connection policy.
 * In HTTP routes, additional placeholders are available (replace any `*`):
 * Placeholder | Description
 * ------------|---------------
 * `{http.request.body}` | The request body (⚠️ inefficient; use only for debugging)
 * `{http.request.cookie.*}` | HTTP request cookie
 * `{http.request.duration}` | Time up to now spent handling the request (after decoding headers from client)
 * `{http.request.duration_ms}` | Same as 'duration', but in milliseconds.
 * `{http.request.uuid}` | The request unique identifier
 * `{http.request.header.*}` | Specific request header field
 * `{http.request.host}` | The host part of the request's Host header
 * `{http.request.host.labels.*}` | Request host labels (0-based from right); e.g. for foo.example.com: 0=com, 1=example, 2=foo
 * `{http.request.hostport}` | The host and port from the request's Host header
 * `{http.request.method}` | The request method
 * `{http.request.orig_method}` | The request's original method
 * `{http.request.orig_uri}` | The request's original URI
 * `{http.request.orig_uri.path}` | The request's original path
 * `{http.request.orig_uri.path.*}` | Parts of the original path, split by `/` (0-based from left)
 * `{http.request.orig_uri.path.dir}` | The request's original directory
 * `{http.request.orig_uri.path.file}` | The request's original filename
 * `{http.request.orig_uri.query}` | The request's original query string (without `?`)
 * `{http.request.port}` | The port part of the request's Host header
 * `{http.request.proto}` | The protocol of the request
 * `{http.request.local.host}` | The host (IP) part of the local address the connection arrived on
 * `{http.request.local.port}` | The port part of the local address the connection arrived on
 * `{http.request.local}` | The local address the connection arrived on
 * `{http.request.remote.host}` | The host (IP) part of the remote client's address, if available (not known with HTTP/3 early data)
 * `{http.request.remote.port}` | The port part of the remote client's address
 * `{http.request.remote}` | The address of the remote client
 * `{http.request.scheme}` | The request scheme, typically `http` or `https`
 * `{http.request.tls.version}` | The TLS version name
 * `{http.request.tls.cipher_suite}` | The TLS cipher suite
 * `{http.request.tls.resumed}` | The TLS connection resumed a previous connection
 * `{http.request.tls.proto}` | The negotiated next protocol
 * `{http.request.tls.proto_mutual}` | The negotiated next protocol was advertised by the server
 * `{http.request.tls.server_name}` | The server name requested by the client, if any
 * `{http.request.tls.client.fingerprint}` | The SHA256 checksum of the client certificate
 * `{http.request.tls.client.public_key}` | The public key of the client certificate.
 * `{http.request.tls.client.public_key_sha256}` | The SHA256 checksum of the client's public key.
 * `{http.request.tls.client.certificate_pem}` | The PEM-encoded value of the certificate.
 * `{http.request.tls.client.certificate_der_base64}` | The base64-encoded value of the certificate.
 * `{http.request.tls.client.issuer}` | The issuer DN of the client certificate
 * `{http.request.tls.client.serial}` | The serial number of the client certificate
 * `{http.request.tls.client.subject}` | The subject DN of the client certificate
 * `{http.request.tls.client.san.dns_names.*}` | SAN DNS names(index optional)
 * `{http.request.tls.client.san.emails.*}` | SAN email addresses (index optional)
 * `{http.request.tls.client.san.ips.*}` | SAN IP addresses (index optional)
 * `{http.request.tls.client.san.uris.*}` | SAN URIs (index optional)
 * `{http.request.uri}` | The full request URI
 * `{http.request.uri.path}` | The path component of the request URI
 * `{http.request.uri.path.*}` | Parts of the path, split by `/` (0-based from left)
 * `{http.request.uri.path.dir}` | The directory, excluding leaf filename
 * `{http.request.uri.path.file}` | The filename of the path, excluding directory
 * `{http.request.uri.query}` | The query string (without `?`)
 * `{http.request.uri.query.*}` | Individual query string value
 * `{http.response.header.*}` | Specific response header field
 * `{http.vars.*}` | Custom variables in the HTTP handler chain
 * `{http.shutting_down}` | True if the HTTP app is shutting down
 * `{http.time_until_shutdown}` | Time until HTTP server shutdown, if scheduled
 */
export interface App {
  /**
   * HTTPPort specifies the port to use for HTTP (as opposed to HTTPS),
   * which is used when setting up HTTP->HTTPS redirects or ACME HTTP
   * challenge solvers. Default: 80.
   */
  http_port?: number /* int */;
  /**
   * HTTPSPort specifies the port to use for HTTPS, which is used when
   * solving the ACME TLS-ALPN challenges, or whenever HTTPS is needed
   * but no specific port number is given. Default: 443.
   */
  https_port?: number /* int */;
  /**
   * GracePeriod is how long to wait for active connections when shutting
   * down the servers. During the grace period, no new connections are
   * accepted, idle connections are closed, and active connections will
   * be given the full length of time to become idle and close.
   * Once the grace period is over, connections will be forcefully closed.
   * If zero, the grace period is eternal. Default: 0.
   */
  grace_period?: Duration;
  /**
   * ShutdownDelay is how long to wait before initiating the grace
   * period. When this app is stopping (e.g. during a config reload or
   * process exit), all servers will be shut down. Normally this immediately
   * initiates the grace period. However, if this delay is configured, servers
   * will not be shut down until the delay is over. During this time, servers
   * continue to function normally and allow new connections. At the end, the
   * grace period will begin. This can be useful to allow downstream load
   * balancers time to move this instance out of the rotation without hiccups.
   * When shutdown has been scheduled, placeholders {http.shutting_down} (bool)
   * and {http.time_until_shutdown} (duration) may be useful for health checks.
   */
  shutdown_delay?: Duration;
  /**
   * Servers is the list of servers, keyed by arbitrary names chosen
   * at your discretion for your own convenience; the keys do not
   * affect functionality.
   */
  servers?: { [key: string]: Server | undefined };
  /**
   * If set, metrics observations will be enabled.
   * This setting is EXPERIMENTAL and subject to change.
   */
  metrics?: Metrics;
}

//////////
// source: autohttps.go

/**
 * AutoHTTPSConfig is used to disable automatic HTTPS
 * or certain aspects of it for a specific server.
 * HTTPS is enabled automatically and by default when
 * qualifying hostnames are available from the config.
 */
export interface AutoHTTPSConfig {
  /**
   * If true, automatic HTTPS will be entirely disabled,
   * including certificate management and redirects.
   */
  disable?: boolean;
  /**
   * If true, only automatic HTTP->HTTPS redirects will
   * be disabled, but other auto-HTTPS features will
   * remain enabled.
   */
  disable_redirects?: boolean;
  /**
   * If true, automatic certificate management will be
   * disabled, but other auto-HTTPS features will
   * remain enabled.
   */
  disable_certificates?: boolean;
  /**
   * Hosts/domain names listed here will not be included
   * in automatic HTTPS (they will not have certificates
   * loaded nor redirects applied).
   */
  skip?: string[];
  /**
   * Hosts/domain names listed here will still be enabled
   * for automatic HTTPS (unless in the Skip list), except
   * that certificates will not be provisioned and managed
   * for these names.
   */
  skip_certificates?: string[];
  /**
   * By default, automatic HTTPS will obtain and renew
   * certificates for qualifying hostnames. However, if
   * a certificate with a matching SAN is already loaded
   * into the cache, certificate management will not be
   * enabled. To force automated certificate management
   * regardless of loaded certificates, set this to true.
   */
  ignore_loaded_certificates?: boolean;
}

//////////
// source: caddyhttp.go

/**
 * RequestMatcher is a type that can match to a request.
 * A route matcher MUST NOT modify the request, with the
 * only exception being its context.
 * Deprecated: Matchers should now implement RequestMatcherWithError.
 * You may remove any interface guards for RequestMatcher
 * but keep your Match() methods for backwards compatibility.
 */
export type RequestMatcher = any;
/**
 * RequestMatcherWithError is like RequestMatcher but can return an error.
 * An error during matching will abort the request middleware chain and
 * invoke the error middleware chain.
 * This will eventually replace RequestMatcher. Matcher modules
 * should implement both interfaces, and once all modules have
 * been updated to use RequestMatcherWithError, the RequestMatcher
 * interface may eventually be dropped.
 */
export type RequestMatcherWithError = any;
/**
 * Handler is like http.Handler except ServeHTTP may return an error.
 * If any handler encounters an error, it should be returned for proper
 * handling. Return values should be propagated down the middleware chain
 * by returning it unchanged. Returned errors should not be re-wrapped
 * if they are already HandlerError values.
 */
export type Handler = any;
/**
 * HandlerFunc is a convenience type like http.HandlerFunc.
 */
export type HandlerFunc = any;
/**
 * Middleware chains one Handler to the next by being passed
 * the next Handler in the chain.
 */
export type Middleware = any;
/**
 * MiddlewareHandler is like Handler except it takes as a third
 * argument the next handler in the chain. The next handler will
 * never be nil, but may be a no-op handler if this is the last
 * handler in the chain. Handlers which act as middleware should
 * call the next handler's ServeHTTP method so as to propagate
 * the request down the chain properly. Handlers which act as
 * responders (content origins) need not invoke the next handler,
 * since the last handler in the chain should be the first to
 * write the response.
 */
export type MiddlewareHandler = any;
/**
 * ResponseHandler pairs a response matcher with custom handling
 * logic. Either the status code can be changed to something else
 * while using the original response body, or, if a status code
 * is not set, it can execute a custom route list; this is useful
 * for executing handler routes based on the properties of an HTTP
 * response that has not been written out to the client yet.
 * To use this type, provision it at module load time, then when
 * ready to use, match the response against its matcher; if it
 * matches (or doesn't have a matcher), change the status code on
 * the response if configured; otherwise invoke the routes by
 * calling `rh.Routes.Compile(next).ServeHTTP(rw, req)` (or similar).
 */
export interface ResponseHandler {
  /**
   * The response matcher for this handler. If empty/nil,
   * it always matches.
   */
  match?: ResponseMatcher;
  /**
   * To write the original response body but with a different
   * status code, set this field to the desired status code.
   * If set, this takes priority over routes.
   */
  status_code?: WeakString;
  /**
   * The list of HTTP routes to execute if no status code is
   * specified. If evaluated, the original response body
   * will not be written.
   */
  routes?: RouteList;
}
/**
 * WeakString is a type that unmarshals any JSON value
 * as a string literal, with the following exceptions:
 * 1. actual string values are decoded as strings; and
 * 2. null is decoded as empty string;
 * and provides methods for getting the value as various
 * primitive types. However, using this type removes any
 * type safety as far as deserializing JSON is concerned.
 */
export type WeakString = string;
/**
 * DefaultHTTPPort is the default port for HTTP.
 */
export const DefaultHTTPPort = 80;
/**
 * DefaultHTTPSPort is the default port for HTTPS.
 */
export const DefaultHTTPSPort = 443;

//////////
// source: celmatcher.go

/**
 * MatchExpression matches requests by evaluating a
 * [CEL](https://github.com/google/cel-spec) expression.
 * This enables complex logic to be expressed using a comfortable,
 * familiar syntax. Please refer to
 * [the standard definitions of CEL functions and operators](https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions).
 * This matcher's JSON interface is actually a string, not a struct.
 * The generated docs are not correct because this type has custom
 * marshaling logic.
 * COMPATIBILITY NOTE: This module is still experimental and is not
 * subject to Caddy's compatibility guarantee.
 */
export interface MatchExpression {
  /**
   * The CEL expression to evaluate. Any Caddy placeholders
   * will be expanded and situated into proper CEL function
   * calls before evaluating.
   */
  expr?: string;
  /**
   * Name is an optional name for this matcher.
   * This is used to populate the name for regexp
   * matchers that appear in the expression.
   */
  name?: string;
}
/**
 * CELLibraryProducer provide CEL libraries that expose a Matcher
 * implementation as a first class function within the CEL expression
 * matcher.
 */
export type CELLibraryProducer = any;
/**
 * CELMatcherFactory converts a constant CEL value into a RequestMatcher.
 * Deprecated: Use CELMatcherWithErrorFactory instead.
 */
export type CELMatcherFactory = any;
/**
 * CELMatcherWithErrorFactory converts a constant CEL value into a RequestMatcherWithError.
 */
export type CELMatcherWithErrorFactory = any;
/**
 * The name of the CEL function which accesses Replacer values.
 */
export const CELPlaceholderFuncName = "ph";
/**
 * The name of the CEL request variable.
 */
export const CELRequestVarName = "req";
export const MatcherNameCtxKey = "matcher_name";

//////////
// source: errors.go

/**
 * HandlerError is a serializable representation of
 * an error from within an HTTP handler.
 */
export interface HandlerError {
  Err: Error | null; // the original error value and message
  StatusCode: number /* int */; // the HTTP status code to associate with this error
  ID: string; // generated; for identifying this error in logs
  Trace: string; // produced from call stack
}
/**
 * ErrorCtxKey is the context key to use when storing
 * an error (for use with context.Context).
 */
// export const ErrorCtxKey = any; // Disabled - Go context key

//////////
// source: http2listener.go

//////////
// source: httpredirectlistener.go

/**
 * HTTPRedirectListenerWrapper provides HTTP->HTTPS redirects for
 * connections that come on the TLS port as an HTTP request,
 * by detecting using the first few bytes that it's not a TLS
 * handshake, but instead an HTTP request.
 * This is especially useful when using a non-standard HTTPS port.
 * A user may simply type the address in their browser without the
 * https:// scheme, which would cause the browser to attempt the
 * connection over HTTP, but this would cause a "Client sent an
 * HTTP request to an HTTPS server" error response.
 * This listener wrapper must be placed BEFORE the "tls" listener
 * wrapper, for it to work properly.
 */
export interface HTTPRedirectListenerWrapper {
  /**
   * MaxHeaderBytes is the maximum size to parse from a client's
   * HTTP request headers. Default: 1 MB
   */
  max_header_bytes?: number /* int64 */;
}

//////////
// source: invoke.go

/**
 * Invoke implements a handler that compiles and executes a
 * named route that was defined on the server.
 * EXPERIMENTAL: Subject to change or removal.
 */
export interface Invoke {
  /**
   * Name is the key of the named route to execute
   */
  name?: string;
}

//////////
// source: ip_matchers.go

/**
 * MatchRemoteIP matches requests by the remote IP address,
 * i.e. the IP address of the direct connection to Caddy.
 */
export interface MatchRemoteIP {
  /**
   * The IPs or CIDR ranges to match.
   */
  ranges?: string[];
}
/**
 * MatchClientIP matches requests by the client IP address,
 * i.e. the resolved address, considering trusted proxies.
 */
export interface MatchClientIP {
  /**
   * The IPs or CIDR ranges to match.
   */
  ranges?: string[];
}

//////////
// source: ip_range.go

/**
 * IPRangeSource gets a list of IP ranges.
 * The request is passed as an argument to allow plugin implementations
 * to have more flexibility. But, a plugin MUST NOT modify the request.
 * The caller will have read the `r.RemoteAddr` before getting IP ranges.
 * This should be a very fast function -- instant if possible.
 * The list of IP ranges should be sourced as soon as possible if loaded
 * from an external source (i.e. initially loaded during Provisioning),
 * so that it's ready to be used when requests start getting handled.
 * A read lock should probably be used to get the cached value if the
 * ranges can change at runtime (e.g. periodically refreshed).
 * Using a `caddy.UsagePool` may be a good idea to avoid having refetch
 * the values when a config reload occurs, which would waste time.
 * If the list of IP ranges cannot be sourced, then provisioning SHOULD
 * fail. Getting the IP ranges at runtime MUST NOT fail, because it would
 * cancel incoming requests. If refreshing the list fails, then the
 * previous list of IP ranges should continue to be returned so that the
 * server can continue to operate normally.
 */
export type IPRangeSource = any;
/**
 * StaticIPRange provides a static range of IP address prefixes (CIDRs).
 */
export interface StaticIPRange {
  /**
   * A static list of IP ranges (supports CIDR notation).
   */
  ranges?: string[];
}

//////////
// source: logging.go

/**
 * ServerLogConfig describes a server's logging configuration. If
 * enabled without customization, all requests to this server are
 * logged to the default logger; logger destinations may be
 * customized per-request-host.
 */
export interface ServerLogConfig {
  /**
   * The default logger name for all logs emitted by this server for
   * hostnames that are not in the logger_names map.
   */
  default_logger_name?: string;
  /**
   * LoggerNames maps request hostnames to one or more custom logger
   * names. For example, a mapping of `"example.com": ["example"]` would
   * cause access logs from requests with a Host of example.com to be
   * emitted by a logger named "http.log.access.example". If there are
   * multiple logger names, then the log will be emitted to all of them.
   * If the logger name is an empty, the default logger is used, i.e.
   * the logger "http.log.access".
   * Keys must be hostnames (without ports), and may contain wildcards
   * to match subdomains. The value is an array of logger names.
   * For backwards compatibility, if the value is a string, it is treated
   * as a single-element array.
   */
  logger_names?: { [key: string]: StringArray };
  /**
   * By default, all requests to this server will be logged if
   * access logging is enabled. This field lists the request
   * hosts for which access logging should be disabled.
   */
  skip_hosts?: string[];
  /**
   * If true, requests to any host not appearing in the
   * logger_names map will not be logged.
   */
  skip_unmapped_hosts?: boolean;
  /**
   * If true, credentials that are otherwise omitted, will be logged.
   * The definition of credentials is defined by https://fetch.spec.whatwg.org/#credentials,
   * and this includes some request and response headers, i.e `Cookie`,
   * `Set-Cookie`, `Authorization`, and `Proxy-Authorization`.
   */
  should_log_credentials?: boolean;
  /**
   * Log each individual handler that is invoked.
   * Requires that the log emit at DEBUG level.
   * NOTE: This may log the configuration of your
   * HTTP handler modules; do not enable this in
   * insecure contexts when there is sensitive
   * data in the configuration.
   * EXPERIMENTAL: Subject to change or removal.
   */
  trace?: boolean;
}
/**
 * StringArray is a slices of strings, but also accepts
 * a single string as a value when JSON unmarshaling,
 * converting it to a slice of one string.
 */
export type StringArray = string[];
/**
 * ExtraLogFields is a list of extra fields to log with every request.
 */
export interface ExtraLogFields {}
/**
 * Variable name used to indicate that this request
 * should be omitted from the access logs
 */
export const LogSkipVar: string = "log_skip";
/**
 * For adding additional fields to the access logs
 */
export const ExtraLogFieldsCtxKey: any /* caddy.CtxKey */ = "extra_log_fields";
/**
 * Variable name used to indicate the logger to be used
 */
export const AccessLoggerNameVarKey: string = "access_logger_names";

//////////
// source: marshalers.go

/**
 * LoggableHTTPRequest makes an HTTP request loggable with zap.Object().
 */
export interface LoggableHTTPRequest {
  Request?: any /* http.Request */;
  ShouldLogCredentials: boolean;
}
/**
 * LoggableHTTPHeader makes an HTTP header loggable with zap.Object().
 * Headers with potentially sensitive information (Cookie, Set-Cookie,
 * Authorization, and Proxy-Authorization) are logged with empty values.
 */
export interface LoggableHTTPHeader {
  Header: any /* http.Header */;
  ShouldLogCredentials: boolean;
}
/**
 * LoggableStringArray makes a slice of strings marshalable for logging.
 */
export type LoggableStringArray = string[];
/**
 * LoggableTLSConnState makes a TLS connection state loggable with zap.Object().
 */
export type LoggableTLSConnState = any /* tls.ConnectionState */;

//////////
// source: matchers.go

/**
 * MatchHost matches requests by the Host value (case-insensitive).
 * When used in a top-level HTTP route,
 * [qualifying domain names](/docs/automatic-https#hostname-requirements)
 * may trigger [automatic HTTPS](/docs/automatic-https), which automatically
 * provisions and renews certificates for you. Before doing this, you
 * should ensure that DNS records for these domains are properly configured,
 * especially A/AAAA pointed at your server.
 * Automatic HTTPS can be
 * [customized or disabled](/docs/modules/http#servers/automatic_https).
 * Wildcards (`*`) may be used to represent exactly one label of the
 * hostname, in accordance with RFC 1034 (because host matchers are also
 * used for automatic HTTPS which influences TLS certificates). Thus,
 * a host of `*` matches hosts like `localhost` or `internal` but not
 * `example.com`. To catch all hosts, omit the host matcher entirely.
 * The wildcard can be useful for matching all subdomains, for example:
 * `*.example.com` matches `foo.example.com` but not `foo.bar.example.com`.
 * Duplicate entries will return an error.
 */
export type MatchHost = string[];
/**
 * MatchPath case-insensitively matches requests by the URI's path. Path
 * matching is exact, not prefix-based, giving you more control and clarity
 * over matching. Wildcards (`*`) may be used:
 * - At the end only, for a prefix match (`/prefix/*`)
 * - At the beginning only, for a suffix match (`*.suffix`)
 * - On both sides only, for a substring match (`*\/contains/*`)
 * - In the middle, for a globular match (`/accounts/*\/info`)
 * Slashes are significant; i.e. `/foo*` matches `/foo`, `/foo/`, `/foo/bar`,
 * and `/foobar`; but `/foo/*` does not match `/foo` or `/foobar`. Valid
 * paths start with a slash `/`.
 * Because there are, in general, multiple possible escaped forms of any
 * path, path matchers operate in unescaped space; that is, path matchers
 * should be written in their unescaped form to prevent ambiguities and
 * possible security issues, as all request paths will be normalized to
 * their unescaped forms before matcher evaluation.
 * However, escape sequences in a match pattern are supported; they are
 * compared with the request's raw/escaped path for those bytes only.
 * In other words, a matcher of `/foo%2Fbar` will match a request path
 * of precisely `/foo%2Fbar`, but not `/foo/bar`. It follows that matching
 * the literal percent sign (%) in normalized space can be done using the
 * escaped form, `%25`.
 * Even though wildcards (`*`) operate in the normalized space, the special
 * escaped wildcard (`%*`), which is not a valid escape sequence, may be
 * used in place of a span that should NOT be decoded; that is, `/bands/%*`
 * will match `/bands/AC%2fDC` whereas `/bands/*` will not.
 * Even though path matching is done in normalized space, the special
 * wildcard `%*` may be used in place of a span that should NOT be decoded;
 * that is, `/bands/%*\/` will match `/bands/AC%2fDC/` whereas `/bands/*\/`
 * will not.
 * This matcher is fast, so it does not support regular expressions or
 * capture groups. For slower but more powerful matching, use the
 * path_regexp matcher. (Note that due to the special treatment of
 * escape sequences in matcher patterns, they may perform slightly slower
 * in high-traffic environments.)
 */
export type MatchPath = string[];
/**
 * MatchPathRE matches requests by a regular expression on the URI's path.
 * Path matching is performed in the unescaped (decoded) form of the path.
 * Upon a match, it adds placeholders to the request: `{http.regexp.name.capture_group}`
 * where `name` is the regular expression's name, and `capture_group` is either
 * the named or positional capture group from the expression itself. If no name
 * is given, then the placeholder omits the name: `{http.regexp.capture_group}`
 * (potentially leading to collisions).
 */
export interface MatchPathRE {
  MatchRegexp: MatchRegexp;
}
/**
 * MatchMethod matches requests by the method.
 */
export type MatchMethod = string[];
/**
 * MatchQuery matches requests by the URI's query string. It takes a JSON object
 * keyed by the query keys, with an array of string values to match for that key.
 * Query key matches are exact, but wildcards may be used for value matches. Both
 * keys and values may be placeholders.
 * An example of the structure to match `?key=value&topic=api&query=something` is:
 * ```json
 * {
 * 	"key": ["value"],
 * 	"topic": ["api"],
 * 	"query": ["*"]
 * }
 * ```
 * Invalid query strings, including those with bad escapings or illegal characters
 * like semicolons, will fail to parse and thus fail to match.
 * **NOTE:** Notice that query string values are arrays, not singular values. This is
 * because repeated keys are valid in query strings, and each one may have a
 * different value. This matcher will match for a key if any one of its configured
 * values is assigned in the query string. Backend applications relying on query
 * strings MUST take into consideration that query string values are arrays and can
 * have multiple values.
 */
export type MatchQuery = any /* url.Values */;
/**
 * MatchHeader matches requests by header fields. The key is the field
 * name and the array is the list of field values. It performs fast,
 * exact string comparisons of the field values. Fast prefix, suffix,
 * and substring matches can also be done by suffixing, prefixing, or
 * surrounding the value with the wildcard `*` character, respectively.
 * If a list is null, the header must not exist. If the list is empty,
 * the field must simply exist, regardless of its value.
 * **NOTE:** Notice that header values are arrays, not singular values. This is
 * because repeated fields are valid in headers, and each one may have a
 * different value. This matcher will match for a field if any one of its configured
 * values matches in the header. Backend applications relying on headers MUST take
 * into consideration that header field values are arrays and can have multiple
 * values.
 */
export type MatchHeader = any /* http.Header */;
/**
 * MatchHeaderRE matches requests by a regular expression on header fields.
 * Upon a match, it adds placeholders to the request: `{http.regexp.name.capture_group}`
 * where `name` is the regular expression's name, and `capture_group` is either
 * the named or positional capture group from the expression itself. If no name
 * is given, then the placeholder omits the name: `{http.regexp.capture_group}`
 * (potentially leading to collisions).
 */
export type MatchHeaderRE = { [key: string]: MatchRegexp | undefined };
/**
 * MatchProtocol matches requests by protocol. Recognized values are
 * "http", "https", and "grpc" for broad protocol matches, or specific
 * HTTP versions can be specified like so: "http/1", "http/1.1",
 * "http/2", "http/3", or minimum versions: "http/2+", etc.
 */
export type MatchProtocol = string;
/**
 * MatchTLS matches HTTP requests based on the underlying
 * TLS connection state. If this matcher is specified but
 * the request did not come over TLS, it will never match.
 * If this matcher is specified but is empty and the request
 * did come in over TLS, it will always match.
 */
export interface MatchTLS {
  /**
   * Matches if the TLS handshake has completed. QUIC 0-RTT early
   * data may arrive before the handshake completes. Generally, it
   * is unsafe to replay these requests if they are not idempotent;
   * additionally, the remote IP of early data packets can more
   * easily be spoofed. It is conventional to respond with HTTP 425
   * Too Early if the request cannot risk being processed in this
   * state.
   */
  handshake_complete?: boolean;
}
/**
 * MatchNot matches requests by negating the results of its matcher
 * sets. A single "not" matcher takes one or more matcher sets. Each
 * matcher set is OR'ed; in other words, if any matcher set returns
 * true, the final result of the "not" matcher is false. Individual
 * matchers within a set work the same (i.e. different matchers in
 * the same set are AND'ed).
 * NOTE: The generated docs which describe the structure of this
 * module are wrong because of how this type unmarshals JSON in a
 * custom way. The correct structure is:
 * ```json
 * [
 * 	{},
 * 	{}
 * ]
 * ```
 * where each of the array elements is a matcher set, i.e. an
 * object keyed by matcher name.
 */
export interface MatchNot {}
/**
 * MatchRegexp is an embedable type for matching
 * using regular expressions. It adds placeholders
 * to the request's replacer.
 */
export interface MatchRegexp {
  /**
   * A unique name for this regular expression. Optional,
   * but useful to prevent overwriting captures from other
   * regexp matchers.
   */
  name?: string;
  /**
   * The regular expression to evaluate, in RE2 syntax,
   * which is the same general syntax used by Go, Perl,
   * and Python. For details, see
   * [Go's regexp package](https://golang.org/pkg/regexp/).
   * Captures are accessible via placeholders. Unnamed
   * capture groups are exposed as their numeric, 1-based
   * index, while named capture groups are available by
   * the capture group name.
   */
  pattern: string;
}
/**
 * MatcherErrorVarKey is the key used for the variable that
 * holds an optional error emitted from a request matcher,
 * to short-circuit the handler chain, since matchers cannot
 * return errors via the RequestMatcher interface.
 * Deprecated: Matchers should implement RequestMatcherWithError
 * which can return an error directly, instead of smuggling it
 * through the vars map.
 */
export const MatcherErrorVarKey = "matchers.error";

//////////
// source: metrics.go

/**
 * Metrics configures metrics observations.
 * EXPERIMENTAL and subject to change or removal.
 * Example configuration:
 * 	{
 * 		"apps": {
 * 			"http": {
 * 				"metrics": {
 * 					"per_host": true,
 * 					"allow_catch_all_hosts": false
 * 				},
 * 				"servers": {
 * 					"srv0": {
 * 						"routes": [{
 * 							"match": [{"host": ["example.com", "www.example.com"]}],
 * 							"handle": [{"handler": "static_response", "body": "Hello"}]
 * 						}]
 * 					}
 * 				}
 * 			}
 * 		}
 * 	}
 * In this configuration:
 * - Requests to example.com and www.example.com get individual host labels
 * - All other hosts (e.g., attacker.com) are aggregated under "_other" label
 * - This prevents unlimited cardinality from arbitrary Host headers
 */
export interface Metrics {
  /**
   * Enable per-host metrics. Enabling this option may
   * incur high-memory consumption, depending on the number of hosts
   * managed by Caddy.
   * CARDINALITY PROTECTION: To prevent unbounded cardinality attacks,
   * only explicitly configured hosts (via host matchers) are allowed
   * by default. Other hosts are aggregated under the "_other" label.
   * See AllowCatchAllHosts to change this behavior.
   */
  per_host?: boolean;
  /**
   * Allow metrics for catch-all hosts (hosts without explicit configuration).
   * When false (default), only hosts explicitly configured via host matchers
   * will get individual metrics labels. All other hosts will be aggregated
   * under the "_other" label to prevent cardinality explosion.
   * This is automatically enabled for HTTPS servers (since certificates provide
   * some protection against unbounded cardinality), but disabled for HTTP servers
   * by default to prevent cardinality attacks from arbitrary Host headers.
   * Set to true to allow all hosts to get individual metrics (NOT RECOMMENDED
   * for production environments exposed to the internet).
   */
  allow_catch_all_hosts?: boolean;
}

//////////
// source: replacer.go

//////////
// source: responsematchers.go

/**
 * ResponseMatcher is a type which can determine if an
 * HTTP response matches some criteria.
 */
export interface ResponseMatcher {
  /**
   * If set, one of these status codes would be required.
   * A one-digit status can be used to represent all codes
   * in that class (e.g. 3 for all 3xx codes).
   */
  status_code?: number /* int */[];
  /**
   * If set, each header specified must be one of the
   * specified values, with the same logic used by the
   * [request header matcher](/docs/json/apps/http/servers/routes/match/header/).
   */
  headers?: any /* http.Header */;
}

//////////
// source: responsewriter.go

/**
 * ResponseWriterWrapper wraps an underlying ResponseWriter and
 * promotes its Pusher method as well. To use this type, embed
 * a pointer to it within your own struct type that implements
 * the http.ResponseWriter interface, then call methods on the
 * embedded value.
 */
export interface ResponseWriterWrapper {
  ResponseWriter: any /* http.ResponseWriter */;
}
/**
 * ResponseRecorder is a http.ResponseWriter that records
 * responses instead of writing them to the client. See
 * docs for NewResponseRecorder for proper usage.
 */
export type ResponseRecorder = any /* http.ResponseWriter */;
/**
 * ShouldBufferFunc is a function that returns true if the
 * response should be buffered, given the pending HTTP status
 * code and response headers.
 */
export type ShouldBufferFunc = any;

//////////
// source: routes.go

/**
 * Route consists of a set of rules for matching HTTP requests,
 * a list of handlers to execute, and optional flow control
 * parameters which customize the handling of HTTP requests
 * in a highly flexible and performant manner.
 */
export interface Route {
  /**
   * Group is an optional name for a group to which this
   * route belongs. Grouping a route makes it mutually
   * exclusive with others in its group; if a route belongs
   * to a group, only the first matching route in that group
   * will be executed.
   */
  group?: string;
  /**
   * The matcher sets which will be used to qualify this
   * route for a request (essentially the "if" statement
   * of this route). Each matcher set is OR'ed, but matchers
   * within a set are AND'ed together.
   */
  match?: RawMatcherSets;
  /**
   * The list of handlers for this route. Upon matching a request, they are chained
   * together in a middleware fashion: requests flow from the first handler to the last
   * (top of the list to the bottom), with the possibility that any handler could stop
   * the chain and/or return an error. Responses flow back through the chain (bottom of
   * the list to the top) as they are written out to the client.
   * Not all handlers call the next handler in the chain. For example, the reverse_proxy
   * handler always sends a request upstream or returns an error. Thus, configuring
   * handlers after reverse_proxy in the same route is illogical, since they would never
   * be executed. You will want to put handlers which originate the response at the very
   * end of your route(s). The documentation for a module should state whether it invokes
   * the next handler, but sometimes it is common sense.
   * Some handlers manipulate the response. Remember that requests flow down the list, and
   * responses flow up the list.
   * For example, if you wanted to use both `templates` and `encode` handlers, you would
   * need to put `templates` after `encode` in your route, because responses flow up.
   * Thus, `templates` will be able to parse and execute the plain-text response as a
   * template, and then return it up to the `encode` handler which will then compress it
   * into a binary format.
   * If `templates` came before `encode`, then `encode` would write a compressed,
   * binary-encoded response to `templates` which would not be able to parse the response
   * properly.
   * The correct order, then, is this:
   *     [
   *         {"handler": "encode"},
   *         {"handler": "templates"},
   *         {"handler": "file_server"}
   *     ]
   * The request flows ⬇️ DOWN (`encode` -> `templates` -> `file_server`).
   * 1. First, `encode` will choose how to `encode` the response and wrap the response.
   * 2. Then, `templates` will wrap the response with a buffer.
   * 3. Finally, `file_server` will originate the content from a file.
   * The response flows ⬆️ UP (`file_server` -> `templates` -> `encode`):
   * 1. First, `file_server` will write the file to the response.
   * 2. That write will be buffered and then executed by `templates`.
   * 3. Lastly, the write from `templates` will flow into `encode` which will compress the stream.
   * If you think of routes in this way, it will be easy and even fun to solve the puzzle of writing correct routes.
   */
  handle?: unknown[];
  /**
   * If true, no more routes will be executed after this one.
   */
  terminal?: boolean;
}
/**
 * RouteList is a list of server routes that can
 * create a middleware chain.
 */
export type RouteList = Route[];
/**
 * MatcherSet is a set of matchers which
 * must all match in order for the request
 * to be matched successfully.
 */
export type MatcherSet = any[];
/**
 * RawMatcherSets is a group of matcher sets
 * in their raw, JSON form.
 */
export type RawMatcherSets = ModuleMap[];
/**
 * MatcherSets is a group of matcher sets capable
 * of checking whether a request matches any of
 * the sets.
 */
export type MatcherSets = MatcherSet[];

//////////
// source: server.go

/**
 * Server describes an HTTP server.
 */
export interface Server {
  /**
   * Socket addresses to which to bind listeners. Accepts
   * [network addresses](/docs/conventions#network-addresses)
   * that may include port ranges. Listener addresses must
   * be unique; they cannot be repeated across all defined
   * servers.
   */
  listen?: string[];
  /**
   * A list of listener wrapper modules, which can modify the behavior
   * of the base listener. They are applied in the given order.
   */
  listener_wrappers?: unknown[];
  /**
   * How long to allow a read from a client's upload. Setting this
   * to a short, non-zero value can mitigate slowloris attacks, but
   * may also affect legitimately slow clients.
   */
  read_timeout?: Duration;
  /**
   * ReadHeaderTimeout is like ReadTimeout but for request headers.
   * Default is 1 minute.
   */
  read_header_timeout?: Duration;
  /**
   * WriteTimeout is how long to allow a write to a client. Note
   * that setting this to a small value when serving large files
   * may negatively affect legitimately slow clients.
   */
  write_timeout?: Duration;
  /**
   * IdleTimeout is the maximum time to wait for the next request
   * when keep-alives are enabled. If zero, a default timeout of
   * 5m is applied to help avoid resource exhaustion.
   */
  idle_timeout?: Duration;
  /**
   * KeepAliveInterval is the interval at which TCP keepalive packets
   * are sent to keep the connection alive at the TCP layer when no other
   * data is being transmitted.
   * If zero, the default is 15s.
   * If negative, keepalive packets are not sent and other keepalive parameters
   * are ignored.
   */
  keepalive_interval?: Duration;
  /**
   * KeepAliveIdle is the time that the connection must be idle before
   * the first TCP keep-alive probe is sent when no other data is being
   * transmitted.
   * If zero, the default is 15s.
   * If negative, underlying socket value is unchanged.
   */
  keepalive_idle?: Duration;
  /**
   * KeepAliveCount is the maximum number of TCP keep-alive probes that
   * should be sent before dropping a connection.
   * If zero, the default is 9.
   * If negative, underlying socket value is unchanged.
   */
  keepalive_count?: number /* int */;
  /**
   * MaxHeaderBytes is the maximum size to parse from a client's
   * HTTP request headers.
   */
  max_header_bytes?: number /* int */;
  /**
   * Enable full-duplex communication for HTTP/1 requests.
   * Only has an effect if Caddy was built with Go 1.21 or later.
   * For HTTP/1 requests, the Go HTTP server by default consumes any
   * unread portion of the request body before beginning to write the
   * response, preventing handlers from concurrently reading from the
   * request and writing the response. Enabling this option disables
   * this behavior and permits handlers to continue to read from the
   * request while concurrently writing the response.
   * For HTTP/2 requests, the Go HTTP server always permits concurrent
   * reads and responses, so this option has no effect.
   * Test thoroughly with your HTTP clients, as some older clients may
   * not support full-duplex HTTP/1 which can cause them to deadlock.
   * See https://github.com/golang/go/issues/57786 for more info.
   * TODO: This is an EXPERIMENTAL feature. Subject to change or removal.
   */
  enable_full_duplex?: boolean;
  /**
   * Routes describes how this server will handle requests.
   * Routes are executed sequentially. First a route's matchers
   * are evaluated, then its grouping. If it matches and has
   * not been mutually-excluded by its grouping, then its
   * handlers are executed sequentially. The sequence of invoked
   * handlers comprises a compiled middleware chain that flows
   * from each matching route and its handlers to the next.
   * By default, all unrouted requests receive a 200 OK response
   * to indicate the server is working.
   */
  routes?: RouteList;
  /**
   * Errors is how this server will handle errors returned from any
   * of the handlers in the primary routes. If the primary handler
   * chain returns an error, the error along with its recommended
   * status code are bubbled back up to the HTTP server which
   * executes a separate error route, specified using this property.
   * The error routes work exactly like the normal routes.
   */
  errors?: HTTPErrorConfig;
  /**
   * NamedRoutes describes a mapping of reusable routes that can be
   * invoked by their name. This can be used to optimize memory usage
   * when the same route is needed for many subroutes, by having
   * the handlers and matchers be only provisioned once, but used from
   * many places. These routes are not executed unless they are invoked
   * from another route.
   * EXPERIMENTAL: Subject to change or removal.
   */
  named_routes?: { [key: string]: Route | undefined };
  /**
   * How to handle TLS connections. At least one policy is
   * required to enable HTTPS on this server if automatic
   * HTTPS is disabled or does not apply.
   */
  tls_connection_policies?: TlsConnectionPolicy[];
  /**
   * AutoHTTPS configures or disables automatic HTTPS within this server.
   * HTTPS is enabled automatically and by default when qualifying names
   * are present in a Host matcher and/or when the server is listening
   * only on the HTTPS port.
   */
  automatic_https?: AutoHTTPSConfig;
  /**
   * If true, will require that a request's Host header match
   * the value of the ServerName sent by the client's TLS
   * ClientHello; often a necessary safeguard when using TLS
   * client authentication.
   */
  strict_sni_host?: boolean;
  /**
   * A module which provides a source of IP ranges, from which
   * requests should be trusted. By default, no proxies are
   * trusted.
   * On its own, this configuration will not do anything,
   * but it can be used as a default set of ranges for
   * handlers or matchers in routes to pick up, instead
   * of needing to configure each of them. See the
   * `reverse_proxy` handler for example, which uses this
   * to trust sensitive incoming `X-Forwarded-*` headers.
   */
  trusted_proxies?: unknown;
  /**
   * The headers from which the client IP address could be
   * read from. These will be considered in order, with the
   * first good value being used as the client IP.
   * By default, only `X-Forwarded-For` is considered.
   * This depends on `trusted_proxies` being configured and
   * the request being validated as coming from a trusted
   * proxy, otherwise the client IP will be set to the direct
   * remote IP address.
   */
  client_ip_headers?: string[];
  /**
   * If greater than zero, enables strict ClientIPHeaders
   * (default X-Forwarded-For) parsing. If enabled, the
   * ClientIPHeaders will be parsed from right to left, and
   * the first value that is both valid and doesn't match the
   * trusted proxy list will be used as client IP. If zero,
   * the ClientIPHeaders will be parsed from left to right,
   * and the first value that is a valid IP address will be
   * used as client IP.
   * This depends on `trusted_proxies` being configured.
   * This option is disabled by default.
   */
  trusted_proxies_strict?: number /* int */;
  /**
   * If greater than zero, enables trusting socket connections
   * (e.g. Unix domain sockets) as coming from a trusted
   * proxy.
   * This option is disabled by default.
   */
  trusted_proxies_unix?: boolean;
  /**
   * Enables access logging and configures how access logs are handled
   * in this server. To minimally enable access logs, simply set this
   * to a non-null, empty struct.
   */
  logs?: ServerLogConfig;
  /**
   * Protocols specifies which HTTP protocols to enable.
   * Supported values are:
   * - `h1` (HTTP/1.1)
   * - `h2` (HTTP/2)
   * - `h2c` (cleartext HTTP/2)
   * - `h3` (HTTP/3)
   * If enabling `h2` or `h2c`, `h1` must also be enabled;
   * this is due to current limitations in the Go standard
   * library.
   * HTTP/2 operates only over TLS (HTTPS). HTTP/3 opens
   * a UDP socket to serve QUIC connections.
   * H2C operates over plain TCP if the client supports it;
   * however, because this is not implemented by the Go
   * standard library, other server options are not compatible
   * and will not be applied to H2C requests. Do not enable this
   * only to achieve maximum client compatibility. In practice,
   * very few clients implement H2C, and even fewer require it.
   * Enabling H2C can be useful for serving/proxying gRPC
   * if encryption is not possible or desired.
   * We recommend for most users to simply let Caddy use the
   * default settings.
   * Default: `[h1 h2 h3]`
   */
  protocols?: string[];
  /**
   * ListenProtocols overrides Protocols for each parallel address in Listen.
   * A nil value or element indicates that Protocols will be used instead.
   */
  listen_protocols?: string[][];
  /**
   * If set, metrics observations will be enabled.
   * This setting is EXPERIMENTAL and subject to change.
   * DEPRECATED: Use the app-level `metrics` field.
   */
  metrics?: Metrics;
}
/**
 * HTTPErrorConfig determines how to handle errors
 * from the HTTP handlers.
 */
export interface HTTPErrorConfig {
  /**
   * The routes to evaluate after the primary handler
   * chain returns an error. In an error route, extra
   * placeholders are available:
   * Placeholder | Description
   * ------------|---------------
   * `{http.error.status_code}` | The recommended HTTP status code
   * `{http.error.status_text}` | The status text associated with the recommended status code
   * `{http.error.message}`     | The error message
   * `{http.error.trace}`       | The origin of the error
   * `{http.error.id}`          | An identifier for this occurrence of the error
   */
  routes?: RouteList;
}
/**
 * For referencing the server instance
 */
export const ServerCtxKey: any /* caddy.CtxKey */ = "server";
/**
 * For the request's variable table
 */
export const VarsCtxKey: any /* caddy.CtxKey */ = "vars";
/**
 * For a partial copy of the unmodified request that
 * originally came into the server's entry handler
 */
export const OriginalRequestCtxKey: any /* caddy.CtxKey */ = "original_request";
/**
 * DEPRECATED: not used anymore.
 * To refer to the underlying connection, implement a middleware plugin
 * that RegisterConnContext during provisioning.
 */
export const ConnCtxKey: any /* caddy.CtxKey */ = "conn";
/**
 * For tracking whether the client is a trusted proxy
 */
export const TrustedProxyVarKey: string = "trusted_proxy";
/**
 * For tracking the real client IP (affected by trusted_proxy)
 */
export const ClientIPVarKey: string = "client_ip";

//////////
// source: staticerror.go

/**
 * StaticError implements a simple handler that returns an error.
 * This handler returns an error value, but does not write a response.
 * This is useful when you want the server to act as if an error
 * occurred; for example, to invoke your custom error handling logic.
 * Since this handler does not write a response, the error information
 * is for use by the server to know how to handle the error.
 */
export interface StaticError {
  /**
   * The error message. Optional. Default is no error message.
   */
  error?: string;
  /**
   * The recommended HTTP status code. Can be either an integer or a
   * string if placeholders are needed. Optional. Default is 500.
   */
  status_code?: WeakString;
}

//////////
// source: staticresp.go

/**
 * StaticResponse implements a simple responder for static responses.
 */
export interface StaticResponse {
  /**
   * The HTTP status code to respond with. Can be an integer or,
   * if needing to use a placeholder, a string.
   * If the status code is 103 (Early Hints), the response headers
   * will be written to the client immediately, the body will be
   * ignored, and the next handler will be invoked. This behavior
   * is EXPERIMENTAL while RFC 8297 is a draft, and may be changed
   * or removed.
   */
  status_code?: WeakString;
  /**
   * Header fields to set on the response; overwrites any existing
   * header fields of the same names after normalization.
   */
  headers?: any /* http.Header */;
  /**
   * The response body. If non-empty, the Content-Type header may
   * be added automatically if it is not explicitly configured nor
   * already set on the response; the default value is
   * "text/plain; charset=utf-8" unless the body is a valid JSON object
   * or array, in which case the value will be "application/json".
   * Other than those common special cases the Content-Type header
   * should be set explicitly if it is desired because MIME sniffing
   * is disabled for safety.
   */
  body?: string;
  /**
   * If true, the server will close the client's connection
   * after writing the response.
   */
  close?: boolean;
  /**
   * Immediately and forcefully closes the connection without
   * writing a response. Interrupts any other HTTP streams on
   * the same connection.
   */
  abort?: boolean;
}

//////////
// source: subroute.go

/**
 * Subroute implements a handler that compiles and executes routes.
 * This is useful for a batch of routes that all inherit the same
 * matchers, or for multiple routes that should be treated as a
 * single route.
 * You can also use subroutes to handle errors from its handlers.
 * First the primary routes will be executed, and if they return an
 * error, the errors routes will be executed; in that case, an error
 * is only returned to the entry point at the server if there is an
 * additional error returned from the errors routes.
 */
export interface Subroute {
  /**
   * The primary list of routes to compile and execute.
   */
  routes?: RouteList;
  /**
   * If the primary routes return an error, error handling
   * can be promoted to this configuration instead.
   */
  errors?: HTTPErrorConfig;
}

//////////
// source: vars.go

/**
 * VarsMiddleware is an HTTP middleware which sets variables to
 * have values that can be used in the HTTP request handler
 * chain. The primary way to access variables is with placeholders,
 * which have the form: `{http.vars.variable_name}`, or with
 * the `vars` and `vars_regexp` request matchers.
 * The key is the variable name, and the value is the value of the
 * variable. Both the name and value may use or contain placeholders.
 */
export type VarsMiddleware = { [key: string]: any };
/**
 * VarsMatcher is an HTTP request matcher which can match
 * requests based on variables in the context or placeholder
 * values. The key is the placeholder or name of the variable,
 * and the values are possible values the variable can be in
 * order to match (logical OR'ed).
 * If the key is surrounded by `{ }` it is assumed to be a
 * placeholder. Otherwise, it will be considered a variable
 * name.
 * Placeholders in the keys are not expanded, but
 * placeholders in the values are.
 */
export type VarsMatcher = { [key: string]: string[] };
/**
 * MatchVarsRE matches the value of the context variables by a given regular expression.
 * Upon a match, it adds placeholders to the request: `{http.regexp.name.capture_group}`
 * where `name` is the regular expression's name, and `capture_group` is either
 * the named or positional capture group from the expression itself. If no name
 * is given, then the placeholder omits the name: `{http.regexp.capture_group}`
 * (potentially leading to collisions).
 */
export type MatchVarsRE = { [key: string]: MatchRegexp | undefined };
