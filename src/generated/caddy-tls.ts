// Code generated by tygo. DO NOT EDIT.

import type { Duration, ModuleMap } from "./caddy-core";

//////////
// source: acmeissuer.go

/**
 * ACMEIssuer manages certificates using the ACME protocol (RFC 8555).
 */
export interface ACMEIssuer {
  /**
   * The URL to the CA's ACME directory endpoint. Default:
   * https://acme-v02.api.letsencrypt.org/directory
   */
  ca?: string;
  /**
   * The URL to the test CA's ACME directory endpoint.
   * This endpoint is only used during retries if there
   * is a failure using the primary CA. Default:
   * https://acme-staging-v02.api.letsencrypt.org/directory
   */
  test_ca?: string;
  /**
   * Your email address, so the CA can contact you if necessary.
   * Not required, but strongly recommended to provide one so
   * you can be reached if there is a problem. Your email is
   * not sent to any Caddy mothership or used for any purpose
   * other than ACME transactions.
   */
  email?: string;
  /**
   * Optionally select an ACME profile to use for certificate
   * orders. Must be a profile name offered by the ACME server,
   * which are listed at its directory endpoint.
   * EXPERIMENTAL: Subject to change.
   * See https://datatracker.ietf.org/doc/draft-aaron-acme-profiles/
   */
  profile?: string;
  /**
   * If you have an existing account with the ACME server, put
   * the private key here in PEM format. The ACME client will
   * look up your account information with this key first before
   * trying to create a new one. You can use placeholders here,
   * for example if you have it in an environment variable.
   */
  account_key?: string;
  /**
   * If using an ACME CA that requires an external account
   * binding, specify the CA-provided credentials here.
   */
  external_account?: any /* acme.EAB */;
  /**
   * Time to wait before timing out an ACME operation.
   * Default: 0 (no timeout)
   */
  acme_timeout?: Duration;
  /**
   * Configures the various ACME challenge types.
   */
  challenges?: ChallengesConfig;
  /**
   * An array of files of CA certificates to accept when connecting to the
   * ACME CA. Generally, you should only use this if the ACME CA endpoint
   * is internal or for development/testing purposes.
   */
  trusted_roots_pem_files?: string[];
  /**
   * Preferences for selecting alternate certificate chains, if offered
   * by the CA. By default, the first offered chain will be selected.
   * If configured, the chains may be sorted and the first matching chain
   * will be selected.
   */
  preferred_chains?: ChainPreference;
  /**
   * The validity period to ask the CA to issue a certificate for.
   * Default: 0 (CA chooses lifetime).
   * This value is used to compute the "notAfter" field of the ACME order;
   * therefore the system must have a reasonably synchronized clock.
   * NOTE: Not all CAs support this. Check with your CA's ACME
   * documentation to see if this is allowed and what values may
   * be used. EXPERIMENTAL: Subject to change.
   */
  certificate_lifetime?: Duration;
  /**
   * Forward proxy module
   */
  network_proxy?: unknown;
}
/**
 * ChainPreference describes the client's preferred certificate chain,
 * useful if the CA offers alternate chains. The first matching chain
 * will be selected.
 */
export interface ChainPreference {
  /**
   * Prefer chains with the fewest number of bytes.
   */
  smallest?: boolean;
  /**
   * Select first chain having a root with one of
   * these common names.
   */
  root_common_name?: string[];
  /**
   * Select first chain that has any issuer with one
   * of these common names.
   */
  any_common_name?: string[];
}

//////////
// source: automation.go

/**
 * AutomationConfig governs the automated management of TLS certificates.
 */
export interface AutomationConfig {
  /**
   * The list of automation policies. The first policy matching
   * a certificate or subject name will be applied.
   */
  policies?: (AutomationPolicy | undefined)[];
  /**
   * On-Demand TLS defers certificate operations to the
   * moment they are needed, e.g. during a TLS handshake.
   * Useful when you don't know all the hostnames at
   * config-time, or when you are not in control of the
   * domain names you are managing certificates for.
   * In 2015, Caddy became the first web server to
   * implement this experimental technology.
   * Note that this field does not enable on-demand TLS;
   * it only configures it for when it is used. To enable
   * it, create an automation policy with `on_demand`.
   */
  on_demand?: OnDemandConfig;
  /**
   * Caddy staples OCSP (and caches the response) for all
   * qualifying certificates by default. This setting
   * changes how often it scans responses for freshness,
   * and updates them if they are getting stale. Default: 1h
   */
  ocsp_interval?: Duration;
  /**
   * Every so often, Caddy will scan all loaded, managed
   * certificates for expiration. This setting changes how
   * frequently the scan for expiring certificates is
   * performed. Default: 10m
   */
  renew_interval?: Duration;
  /**
   * How often to scan storage units for old or expired
   * assets and remove them. These scans exert lots of
   * reads (and list operations) on the storage module, so
   * choose a longer interval for large deployments.
   * Default: 24h
   * Storage will always be cleaned when the process first
   * starts. Then, a new cleaning will be started this
   * duration after the previous cleaning started if the
   * previous cleaning finished in less than half the time
   * of this interval (otherwise next start will be skipped).
   */
  storage_clean_interval?: Duration;
}
/**
 * AutomationPolicy designates the policy for automating the
 * management (obtaining, renewal, and revocation) of managed
 * TLS certificates.
 * An AutomationPolicy value is not valid until it has been
 * provisioned; use the `AddAutomationPolicy()` method on the
 * TLS app to properly provision a new policy.
 */
export interface AutomationPolicy {
  /**
   * Which subjects (hostnames or IP addresses) this policy applies to.
   * This list is a filter, not a command. In other words, it is used
   * only to filter whether this policy should apply to a subject that
   * needs a certificate; it does NOT command the TLS app to manage a
   * certificate for that subject. To have Caddy automate a certificate
   * or specific subjects, use the "automate" certificate loader module
   * of the TLS app.
   */
  subjects?: string[];
  /**
   * The modules that may issue certificates. Default: internal if all
   * subjects do not qualify for public certificates; otherwise acme and
   * zerossl.
   */
  issuers?: unknown[];
  /**
   * Modules that can get a custom certificate to use for any
   * given TLS handshake at handshake-time. Custom certificates
   * can be useful if another entity is managing certificates
   * and Caddy need only get it and serve it. Specifying a Manager
   * enables on-demand TLS, i.e. it has the side-effect of setting
   * the on_demand parameter to `true`.
   * TODO: This is an EXPERIMENTAL feature. Subject to change or removal.
   */
  get_certificate?: unknown[];
  /**
   * If true, certificates will be requested with MustStaple. Not all
   * CAs support this, and there are potentially serious consequences
   * of enabling this feature without proper threat modeling.
   */
  must_staple?: boolean;
  /**
   * How long before a certificate's expiration to try renewing it,
   * as a function of its total lifetime. As a general and conservative
   * rule, it is a good idea to renew a certificate when it has about
   * 1/3 of its total lifetime remaining. This utilizes the majority
   * of the certificate's lifetime while still saving time to
   * troubleshoot problems. However, for extremely short-lived certs,
   * you may wish to increase the ratio to ~1/2.
   */
  renewal_window_ratio?: number /* float64 */;
  /**
   * The type of key to generate for certificates.
   * Supported values: `ed25519`, `p256`, `p384`, `rsa2048`, `rsa4096`.
   */
  key_type?: string;
  /**
   * Optionally configure a separate storage module associated with this
   * manager, instead of using Caddy's global/default-configured storage.
   */
  storage?: unknown;
  /**
   * If true, certificates will be managed "on demand"; that is, during
   * TLS handshakes or when needed, as opposed to at startup or config
   * load. This enables On-Demand TLS for this policy.
   */
  on_demand?: boolean;
  /**
   * If true, private keys already existing in storage
   * will be reused. Otherwise, a new key will be
   * created for every new certificate to mitigate
   * pinning and reduce the scope of key compromise.
   * TEMPORARY: Key pinning is against industry best practices.
   * This property will likely be removed in the future.
   * Do not rely on it forever; watch the release notes.
   */
  reuse_private_keys?: boolean;
  /**
   * Disables OCSP stapling. Disabling OCSP stapling puts clients at
   * greater risk, reduces their privacy, and usually lowers client
   * performance. It is NOT recommended to disable this unless you
   * are able to justify the costs.
   * EXPERIMENTAL. Subject to change.
   */
  disable_ocsp_stapling?: boolean;
  /**
   * Overrides the URLs of OCSP responders embedded in certificates.
   * Each key is a OCSP server URL to override, and its value is the
   * replacement. An empty value will disable querying of that server.
   * EXPERIMENTAL. Subject to change.
   */
  ocsp_overrides?: { [key: string]: string };
}
/**
 * ChallengesConfig configures the ACME challenges.
 */
export interface ChallengesConfig {
  /**
   * HTTP configures the ACME HTTP challenge. This
   * challenge is enabled and used automatically
   * and by default.
   */
  http?: HTTPChallengeConfig;
  /**
   * TLSALPN configures the ACME TLS-ALPN challenge.
   * This challenge is enabled and used automatically
   * and by default.
   */
  "tls-alpn"?: TLSALPNChallengeConfig;
  /**
   * Configures the ACME DNS challenge. Because this
   * challenge typically requires credentials for
   * interfacing with a DNS provider, this challenge is
   * not enabled by default. This is the only challenge
   * type which does not require a direct connection
   * to Caddy from an external server.
   * NOTE: DNS providers are currently being upgraded,
   * and this API is subject to change, but should be
   * stabilized soon.
   */
  dns?: DNSChallengeConfig;
  /**
   * Optionally customize the host to which a listener
   * is bound if required for solving a challenge.
   */
  bind_host?: string;
  /**
   * Whether distributed solving is enabled. This is
   * enabled by default, so this is only used to
   * disable it, which should only need to be done if
   * you cannot reliably or affordably use storage
   * backend for writing/distributing challenge info.
   * (Applies to HTTP and TLS-ALPN challenges.)
   * If set to false, challenges can only be solved
   * from the Caddy instance that initiated the
   * challenge, with the exception of HTTP challenges
   * initiated with the same ACME account that this
   * config uses. (Caddy can still solve those challenges
   * without explicitly writing the info to storage.)
   * Default: true
   */
  distributed?: boolean;
}
/**
 * HTTPChallengeConfig configures the ACME HTTP challenge.
 */
export interface HTTPChallengeConfig {
  /**
   * If true, the HTTP challenge will be disabled.
   */
  disabled?: boolean;
  /**
   * An alternate port on which to service this
   * challenge. Note that the HTTP challenge port is
   * hard-coded into the spec and cannot be changed,
   * so you would have to forward packets from the
   * standard HTTP challenge port to this one.
   */
  alternate_port?: number /* int */;
}
/**
 * TLSALPNChallengeConfig configures the ACME TLS-ALPN challenge.
 */
export interface TLSALPNChallengeConfig {
  /**
   * If true, the TLS-ALPN challenge will be disabled.
   */
  disabled?: boolean;
  /**
   * An alternate port on which to service this
   * challenge. Note that the TLS-ALPN challenge port
   * is hard-coded into the spec and cannot be changed,
   * so you would have to forward packets from the
   * standard TLS-ALPN challenge port to this one.
   */
  alternate_port?: number /* int */;
}
/**
 * DNSChallengeConfig configures the ACME DNS challenge.
 * NOTE: This API is still experimental and is subject to change.
 */
export interface DNSChallengeConfig {
  /**
   * The DNS provider module to use which will manage
   * the DNS records relevant to the ACME challenge.
   * Required.
   */
  provider?: unknown;
  /**
   * The TTL of the TXT record used for the DNS challenge.
   */
  ttl?: Duration;
  /**
   * How long to wait before starting propagation checks.
   * Default: 0 (no wait).
   */
  propagation_delay?: Duration;
  /**
   * Maximum time to wait for temporary DNS record to appear.
   * Set to -1 to disable propagation checks.
   * Default: 2 minutes.
   */
  propagation_timeout?: Duration;
  /**
   * Custom DNS resolvers to prefer over system/built-in defaults.
   * Often necessary to configure when using split-horizon DNS.
   */
  resolvers?: string[];
  /**
   * Override the domain to use for the DNS challenge. This
   * is to delegate the challenge to a different domain,
   * e.g. one that updates faster or one with a provider API.
   */
  override_domain?: string;
}
/**
 * ConfigSetter is implemented by certmagic.Issuers that
 * need access to a parent certmagic.Config as part of
 * their provisioning phase. For example, the ACMEIssuer
 * requires a config so it can access storage and the
 * cache to solve ACME challenges.
 */
export type ConfigSetter = any;

//////////
// source: capools.go

/**
 * The interface to be implemented by all guest modules part of
 * the namespace 'tls.ca_pool.source.'
 */
export type CA = any;
/**
 * InlineCAPool is a certificate authority pool provider coming from
 * a DER-encoded certificates in the config
 */
export interface InlineCAPool {
  /**
   * A list of base64 DER-encoded CA certificates
   * against which to validate client certificates.
   * Client certs which are not signed by any of
   * these CAs will be rejected.
   */
  trusted_ca_certs?: string[];
}
/**
 * FileCAPool generates trusted root certificates pool from the designated DER and PEM file
 */
export interface FileCAPool {
  /**
   * TrustedCACertPEMFiles is a list of PEM file names
   * from which to load certificates of trusted CAs.
   * Client certificates which are not signed by any of
   * these CA certificates will be rejected.
   */
  pem_files?: string[];
}
/**
 * PKIRootCAPool extracts the trusted root certificates from Caddy's native 'pki' app
 */
export interface PKIRootCAPool {
  /**
   * List of the Authority names that are configured in the `pki` app whose root certificates are trusted
   */
  authority?: string[];
}
/**
 * PKIIntermediateCAPool extracts the trusted intermediate certificates from Caddy's native 'pki' app
 */
export interface PKIIntermediateCAPool {
  /**
   * List of the Authority names that are configured in the `pki` app whose intermediate certificates are trusted
   */
  authority?: string[];
}
/**
 * StoragePool extracts the trusted certificates root from Caddy storage
 */
export interface StoragePool {
  /**
   * The storage module where the trusted root certificates are stored. Absent
   * explicit storage implies the use of Caddy default storage.
   */
  storage?: unknown;
  /**
   * The storage key/index to the location of the certificates
   */
  pem_keys?: string[];
}
/**
 * TLSConfig holds configuration related to the TLS configuration for the
 * transport/client.
 * copied from with minor modifications: modules/caddyhttp/reverseproxy/httptransport.go
 */
export interface TLSConfig {
  /**
   * Provides the guest module that provides the trusted certificate authority (CA) certificates
   */
  ca?: unknown;
  /**
   * If true, TLS verification of server certificates will be disabled.
   * This is insecure and may be removed in the future. Do not use this
   * option except in testing or local development environments.
   */
  insecure_skip_verify?: boolean;
  /**
   * The duration to allow a TLS handshake to a server. Default: No timeout.
   */
  handshake_timeout?: Duration;
  /**
   * The server name used when verifying the certificate received in the TLS
   * handshake. By default, this will use the upstream address' host part.
   * You only need to override this if your upstream address does not match the
   * certificate the upstream is likely to use. For example if the upstream
   * address is an IP address, then you would need to configure this to the
   * hostname being served by the upstream server. Currently, this does not
   * support placeholders because the TLS config is not provisioned on each
   * connection, so a static value must be used.
   */
  server_name?: string;
  /**
   * TLS renegotiation level. TLS renegotiation is the act of performing
   * subsequent handshakes on a connection after the first.
   * The level can be:
   *  - "never": (the default) disables renegotiation.
   *  - "once": allows a remote server to request renegotiation once per connection.
   *  - "freely": allows a remote server to repeatedly request renegotiation.
   */
  renegotiation?: string;
}
/**
 * The HTTPCertPool fetches the trusted root certificates from HTTP(S)
 * endpoints. The TLS connection properties can be customized, including custom
 * trusted root certificate. One example usage of this module is to get the trusted
 * certificates from another Caddy instance that is running the PKI app and ACME server.
 */
export interface HTTPCertPool {
  /**
   * the list of URLs that respond with PEM-encoded certificates to trust.
   */
  endpoints?: string[];
  /**
   * Customize the TLS connection knobs to used during the HTTP call
   */
  tls?: TLSConfig;
}

//////////
// source: certmanagers.go

/**
 * Tailscale is a module that can get certificates from the local Tailscale process.
 */
export interface Tailscale {}
/**
 * HTTPCertGetter can get a certificate via HTTP(S) request.
 */
export interface HTTPCertGetter {
  /**
   * The URL from which to download the certificate. Required.
   * The URL will be augmented with query string parameters taken
   * from the TLS handshake:
   * - server_name: The SNI value
   * - signature_schemes: Comma-separated list of hex IDs of signatures
   * - cipher_suites: Comma-separated list of hex IDs of cipher suites
   * To be valid, the response must be HTTP 200 with a PEM body
   * consisting of blocks for the certificate chain and the private
   * key.
   * To indicate that this manager is not managing a certificate for
   * the described handshake, the endpoint should return HTTP 204
   * (No Content). Error statuses will indicate that the manager is
   * capable of providing a certificate but was unable to.
   */
  url?: string;
}

//////////
// source: certselection.go

/**
 * CustomCertSelectionPolicy represents a policy for selecting the certificate
 * used to complete a handshake when there may be multiple options. All fields
 * specified must match the candidate certificate for it to be chosen.
 * This was needed to solve https://github.com/caddyserver/caddy/issues/2588.
 */
export interface CustomCertSelectionPolicy {
  /**
   * The certificate must have one of these serial numbers.
   */
  serial_number?: bigint[];
  /**
   * The certificate must have one of these organization names.
   */
  subject_organization?: string[];
  /**
   * The certificate must use this public key algorithm.
   */
  public_key_algorithm?: PublicKeyAlgorithm;
  /**
   * The certificate must have at least one of the tags in the list.
   */
  any_tag?: string[];
  /**
   * The certificate must have all of the tags in the list.
   */
  all_tags?: string[];
}

//////////
// source: connpolicy.go

/**
 * ConnectionPolicies govern the establishment of TLS connections. It is
 * an ordered group of connection policies; the first matching policy will
 * be used to configure TLS connections at handshake-time.
 */
export type ConnectionPolicies = (ConnectionPolicy | undefined)[];
/**
 * ConnectionPolicy specifies the logic for handling a TLS handshake.
 * An empty policy is valid; safe and sensible defaults will be used.
 */
export interface ConnectionPolicy {
  /**
   * How to match this policy with a TLS ClientHello. If
   * this policy is the first to match, it will be used.
   */
  match?: ModuleMap;
  /**
   * How to choose a certificate if more than one matched
   * the given ServerName (SNI) value.
   */
  certificate_selection?: CustomCertSelectionPolicy;
  /**
   * The list of cipher suites to support. Caddy's
   * defaults are modern and secure.
   */
  cipher_suites?: string[];
  /**
   * The list of elliptic curves to support. Caddy's
   * defaults are modern and secure.
   */
  curves?: string[];
  /**
   * Protocols to use for Application-Layer Protocol
   * Negotiation (ALPN) during the handshake.
   */
  alpn?: string[];
  /**
   * Minimum TLS protocol version to allow. Default: `tls1.2`
   */
  protocol_min?: string;
  /**
   * Maximum TLS protocol version to allow. Default: `tls1.3`
   */
  protocol_max?: string;
  /**
   * Reject TLS connections. EXPERIMENTAL: May change.
   */
  drop?: boolean;
  /**
   * Enables and configures TLS client authentication.
   */
  client_authentication?: ClientAuthentication;
  /**
   * DefaultSNI becomes the ServerName in a ClientHello if there
   * is no policy configured for the empty SNI value.
   */
  default_sni?: string;
  /**
   * FallbackSNI becomes the ServerName in a ClientHello if
   * the original ServerName doesn't match any certificates
   * in the cache. The use cases for this are very niche;
   * typically if a client is a CDN and passes through the
   * ServerName of the downstream handshake but can accept
   * a certificate with the origin's hostname instead, then
   * you would set this to your origin's hostname. Note that
   * Caddy must be managing a certificate for this name.
   * This feature is EXPERIMENTAL and subject to change or removal.
   */
  fallback_sni?: string;
  /**
   * Also known as "SSLKEYLOGFILE", TLS secrets will be written to
   * this file in NSS key log format which can then be parsed by
   * Wireshark and other tools. This is INSECURE as it allows other
   * programs or tools to decrypt TLS connections. However, this
   * capability can be useful for debugging and troubleshooting.
   * **ENABLING THIS LOG COMPROMISES SECURITY!**
   * This feature is EXPERIMENTAL and subject to change or removal.
   */
  insecure_secrets_log?: string;
  /**
   * A module that can manipulate the context passed into CertMagic's
   * certificate management functions during TLS handshakes.
   * EXPERIMENTAL - subject to change or removal.
   */
  handshake_context?: unknown;
}
export type HandshakeContext = any;
/**
 * ClientAuthentication configures TLS client auth.
 */
export interface ClientAuthentication {
  /**
   * Certificate authority module which provides the certificate pool of trusted certificates
   */
  ca?: unknown;
  /**
   * Deprecated: Use the `ca` field with the `tls.ca_pool.source.inline` module instead.
   * A list of base64 DER-encoded CA certificates
   * against which to validate client certificates.
   * Client certs which are not signed by any of
   * these CAs will be rejected.
   */
  trusted_ca_certs?: string[];
  /**
   * Deprecated: Use the `ca` field with the `tls.ca_pool.source.file` module instead.
   * TrustedCACertPEMFiles is a list of PEM file names
   * from which to load certificates of trusted CAs.
   * Client certificates which are not signed by any of
   * these CA certificates will be rejected.
   */
  trusted_ca_certs_pem_files?: string[];
  /**
   * Deprecated: This field is deprecated and will be removed in
   * a future version. Please use the `validators` field instead
   * with the tls.client_auth.verifier.leaf module instead.
   * A list of base64 DER-encoded client leaf certs
   * to accept. If this list is not empty, client certs
   * which are not in this list will be rejected.
   */
  trusted_leaf_certs?: string[];
  /**
   * Client certificate verification modules. These can perform
   * custom client authentication checks, such as ensuring the
   * certificate is not revoked.
   */
  verifiers?: unknown[];
  /**
   * The mode for authenticating the client. Allowed values are:
   * Mode | Description
   * -----|---------------
   * `request` | Ask clients for a certificate, but allow even if there isn't one; do not verify it
   * `require` | Require clients to present a certificate, but do not verify it
   * `verify_if_given` | Ask clients for a certificate; allow even if there isn't one, but verify it if there is
   * `require_and_verify` | Require clients to present a valid certificate that is verified
   * The default mode is `require_and_verify` if any
   * TrustedCACerts or TrustedCACertPEMFiles or TrustedLeafCerts
   * are provided; otherwise, the default mode is `require`.
   */
  mode?: string;
}
/**
 * LeafCertClientAuth verifies the client's leaf certificate.
 */
export interface LeafCertClientAuth {
  leaf_certs_loaders?: unknown[];
}
/**
 * PublicKeyAlgorithm is a JSON-unmarshalable wrapper type.
 */
export type PublicKeyAlgorithm = any /* x509.PublicKeyAlgorithm */;
/**
 * ConnectionMatcher is a type which matches TLS handshakes.
 */
export type ConnectionMatcher = any;
/**
 * LeafCertificateLoader is a type that loads the trusted leaf certificates
 * for the tls.leaf_cert_loader modules
 */
export type LeafCertificateLoader = any;
/**
 * ClientCertificateVerifier is a type which verifies client certificates.
 * It is called during verifyPeerCertificate in the TLS handshake.
 */
export type ClientCertificateVerifier = any;

//////////
// source: ech.go

/**
 * ECH enables Encrypted ClientHello (ECH) and configures its management.
 * ECH helps protect site names (also called "server names" or "domain names"
 * or "SNI"), which are normally sent over plaintext when establishing a TLS
 * connection. With ECH, the true ClientHello is encrypted and wrapped by an
 * "outer" ClientHello that uses a more generic, shared server name that is
 * publicly known.
 * Clients need to know which public name (and other parameters) to use when
 * connecting to a site with ECH, and the methods for this vary; however,
 * major browsers support reading ECH configurations from DNS records (which
 * is typically only secure when DNS-over-HTTPS or DNS-over-TLS is enabled in
 * the client). Caddy has the ability to automatically publish ECH configs to
 * DNS records if a DNS provider is configured either in the TLS app or with
 * each individual publication config object. (Requires a custom build with a
 * DNS provider module.)
 * ECH requires at least TLS 1.3, so any TLS connection policies with ECH
 * applied will automatically upgrade the minimum TLS version to 1.3, even if
 * configured to a lower version.
 * Note that, as of Caddy 2.10.0 (~March 2025), ECH keys are not automatically
 * rotated due to a limitation in the Go standard library (see
 * https://github.com/golang/go/issues/71920). This should be resolved when
 * Go 1.25 is released (~Aug. 2025), and Caddy will be updated to automatically
 * rotate ECH keys/configs at that point.
 * EXPERIMENTAL: Subject to change.
 */
export interface ECH {
  /**
   * The list of ECH configurations for which to automatically generate
   * and rotate keys. At least one is required to enable ECH.
   * It is strongly recommended to use as few ECH configs as possible
   * to maximize the size of your anonymity set (see the ECH specification
   * for a definition). Typically, each server should have only one public
   * name, i.e. one config in this list.
   */
  configs?: ECHConfiguration[];
  /**
   * Publication describes ways to publish ECH configs for clients to
   * discover and use. Without publication, most clients will not use
   * ECH at all, and those that do will suffer degraded performance.
   * Most major browsers support ECH by way of publication to HTTPS
   * DNS RRs. (This also typically requires that they use DoH or DoT.)
   */
  publication?: (ECHPublication | undefined)[];
}
/**
 * ECH represents an Encrypted ClientHello configuration.
 * EXPERIMENTAL: Subject to change.
 */
export interface ECHConfiguration {
  /**
   * The public server name (SNI) that will be used in the outer ClientHello.
   * This should be a domain name for which this server is authoritative,
   * because Caddy will try to provision a certificate for this name. As an
   * outer SNI, it is never used for application data (HTTPS, etc.), but it
   * is necessary for enabling clients to connect securely in some cases.
   * If this field is empty or missing, or if Caddy cannot get a certificate
   * for this domain (e.g. the domain's DNS records do not point to this server),
   * client reliability becomes brittle, and you risk coercing clients to expose
   * true server names in plaintext, which compromises both the privacy of the
   * server and makes clients more vulnerable.
   */
  public_name: string;
}
/**
 * ECHPublication configures publication of ECH config(s). It pairs a list
 * of ECH configs with the list of domains they are assigned to protect, and
 * describes how to publish those configs for those domains.
 * Most servers will have only a single publication config, unless their
 * domains are spread across multiple DNS providers or require different
 * methods of publication.
 * EXPERIMENTAL: Subject to change.
 */
export interface ECHPublication {
  /**
   * The list of ECH configurations to publish, identified by public name.
   * If not set, all configs will be included for publication by default.
   * It is generally advised to maximize the size of your anonymity set,
   * which implies using as few public names as possible for your sites.
   * Usually, only a single public name is used to protect all the sites
   * for a server
   * EXPERIMENTAL: This field may be renamed or have its structure changed.
   */
  configs?: string[];
  /**
   * The list of ("inner") domain names which are protected with the associated
   * ECH configurations.
   * If not set, all server names registered with the TLS module will be
   * added to this list implicitly. (This registration is done automatically
   * by other Caddy apps that use the TLS module. They should register their
   * configured server names for this purpose. For example, the HTTP server
   * registers the hostnames for which it applies automatic HTTPS. This is
   * not something you, the user, have to do.) Most servers
   * Names in this list should not appear in any other publication config
   * object with the same publishers, since the publications will likely
   * overwrite each other.
   * NOTE: In order to publish ECH configs for domains configured for
   * On-Demand TLS that are not explicitly enumerated elsewhere in the
   * config, those domain names will have to be listed here. The only
   * time Caddy knows which domains it is serving with On-Demand TLS is
   * handshake-time, which is too late for publishing ECH configs; it
   * means the first connections would not protect the server names,
   * revealing that information to observers, and thus defeating the
   * purpose of ECH. Hence the need to list them here so Caddy can
   * proactively publish ECH configs before clients connect with those
   * server names in plaintext.
   */
  domains?: string[];
  /**
   * How to publish the ECH configurations so clients can know to use
   * ECH to connect more securely to the server.
   */
  publishers?: ModuleMap;
}
/**
 * ECHDNSProvider can service DNS entries for ECH purposes.
 */
export type ECHDNSProvider = any /* libdns.RecordGetter */ & any /* libdns.RecordSetter */;
/**
 * ECHDNSPublisher configures how to publish an ECH configuration to
 * DNS records for the specified domains.
 * EXPERIMENTAL: Subject to change.
 */
export interface ECHDNSPublisher {
  /**
   * The DNS provider module which will establish the HTTPS record(s).
   */
  provider?: unknown;
}
/**
 * ECHPublisher is an interface for publishing ECHConfigList values
 * so that they can be used by clients.
 */
export type ECHPublisher = any;
/**
 * PublishECHConfigListErrors is returned by ECHPublishers to describe one or more
 * errors publishing an ECH config list from PublishECHConfigList. A non-nil, empty
 * value of this type should never be returned.
 * nolint:errname // The linter wants "Error" convention, but this is a multi-error type.
 */
export type PublishECHConfigListErrors = { [key: string]: Error };

//////////
// source: fileloader.go

/**
 * FileLoader loads certificates and their associated keys from disk.
 */
export type FileLoader = CertKeyFilePair[];
/**
 * CertKeyFilePair pairs certificate and key file names along with their
 * encoding format so that they can be loaded from disk.
 */
export interface CertKeyFilePair {
  /**
   * Path to the certificate (public key) file.
   */
  certificate: string;
  /**
   * Path to the private key file.
   */
  key: string;
  /**
   * The format of the cert and key. Can be "pem". Default: "pem"
   */
  format?: string;
  /**
   * Arbitrary values to associate with this certificate.
   * Can be useful when you want to select a particular
   * certificate when there may be multiple valid candidates.
   */
  tags?: string[];
}

//////////
// source: folderloader.go

/**
 * FolderLoader loads certificates and their associated keys from disk
 * by recursively walking the specified directories, looking for PEM
 * files which contain both a certificate and a key.
 */
export type FolderLoader = string[];

//////////
// source: internalissuer.go

/**
 * InternalIssuer is a certificate issuer that generates
 * certificates internally using a locally-configured
 * CA which can be customized using the `pki` app.
 */
export interface InternalIssuer {
  /**
   * The ID of the CA to use for signing. The default
   * CA ID is "local". The CA can be configured with the
   * `pki` app.
   */
  ca?: string;
  /**
   * The validity period of certificates.
   */
  lifetime?: Duration;
  /**
   * If true, the root will be the issuer instead of
   * the intermediate. This is NOT recommended and should
   * only be used when devices/clients do not properly
   * validate certificate chains.
   */
  sign_with_root?: boolean;
}

//////////
// source: leaffileloader.go

/**
 * LeafFileLoader loads leaf certificates from disk.
 */
export interface LeafFileLoader {
  files?: string[];
}

//////////
// source: leaffolderloader.go

/**
 * LeafFolderLoader loads certificates from disk
 * by recursively walking the specified directories, looking for PEM
 * files which contain a certificate.
 */
export interface LeafFolderLoader {
  folders?: string[];
}

//////////
// source: leafpemloader.go

/**
 * LeafPEMLoader loads leaf certificates by
 * decoding their PEM blocks directly. This has the advantage
 * of not needing to store them on disk at all.
 */
export interface LeafPEMLoader {
  certificates?: string[];
}

//////////
// source: leafstorageloader.go

/**
 * LeafStorageLoader loads leaf certificates from the
 * globally configured storage module.
 */
export interface LeafStorageLoader {
  /**
   * A list of certificate file names to be loaded from storage.
   */
  certificates?: string[];
  /**
   * The storage module where the trusted leaf certificates are stored. Absent
   * explicit storage implies the use of Caddy default storage.
   */
  storage?: unknown;
}

//////////
// source: matchers.go

/**
 * MatchServerName matches based on SNI. Names in
 * this list may use left-most-label wildcards,
 * similar to wildcard certificates.
 */
export type MatchServerName = string[];
/**
 * MatchRegexp is an embeddable type for matching
 * using regular expressions. It adds placeholders
 * to the request's replacer. In fact, it is a copy of
 * caddyhttp.MatchRegexp with a local replacer prefix
 * and placeholders support in a regular expression pattern.
 */
export interface MatchRegexp {
  /**
   * A unique name for this regular expression. Optional,
   * but useful to prevent overwriting captures from other
   * regexp matchers.
   */
  name?: string;
  /**
   * The regular expression to evaluate, in RE2 syntax,
   * which is the same general syntax used by Go, Perl,
   * and Python. For details, see
   * [Go's regexp package](https://golang.org/pkg/regexp/).
   * Captures are accessible via placeholders. Unnamed
   * capture groups are exposed as their numeric, 1-based
   * index, while named capture groups are available by
   * the capture group name.
   */
  pattern: string;
}
/**
 * MatchServerNameRE matches based on SNI using a regular expression.
 */
export interface MatchServerNameRE {
  MatchRegexp: MatchRegexp;
}
/**
 * MatchRemoteIP matches based on the remote IP of the
 * connection. Specific IPs or CIDR ranges can be specified.
 * Note that IPs can sometimes be spoofed, so do not rely
 * on this as a replacement for actual authentication.
 */
export interface MatchRemoteIP {
  /**
   * The IPs or CIDR ranges to match.
   */
  ranges?: string[];
  /**
   * The IPs or CIDR ranges to *NOT* match.
   */
  not_ranges?: string[];
}
/**
 * MatchLocalIP matches based on the IP address of the interface
 * receiving the connection. Specific IPs or CIDR ranges can be specified.
 */
export interface MatchLocalIP {
  /**
   * The IPs or CIDR ranges to match.
   */
  ranges?: string[];
}

//////////
// source: ondemand.go

/**
 * OnDemandConfig configures on-demand TLS, for obtaining
 * needed certificates at handshake-time. Because this
 * feature can easily be abused, Caddy must ask permission
 * to your application whether a particular domain is allowed
 * to have a certificate issued for it.
 */
export interface OnDemandConfig {
  /**
   * Deprecated. WILL BE REMOVED SOON. Use 'permission' instead with the `http` module.
   */
  ask?: string;
  /**
   * REQUIRED. A module that will determine whether a
   * certificate is allowed to be loaded from storage
   * or obtained from an issuer on demand.
   */
  permission?: unknown;
}
/**
 * OnDemandPermission is a type that can give permission for
 * whether a certificate should be allowed to be obtained or
 * loaded from storage on-demand.
 * EXPERIMENTAL: This API is experimental and subject to change.
 */
export type OnDemandPermission = any;
/**
 * PermissionByHTTP determines permission for a TLS certificate by
 * making a request to an HTTP endpoint.
 */
export interface PermissionByHTTP {
  /**
   * The endpoint to access. It should be a full URL.
   * A query string parameter "domain" will be added to it,
   * containing the domain (or IP) for the desired certificate,
   * like so: `?domain=example.com`. Generally, this endpoint
   * is not exposed publicly to avoid a minor information leak
   * (which domains are serviced by your application).
   * The endpoint must return a 200 OK status if a certificate
   * is allowed; anything else will cause it to be denied.
   * Redirects are not followed.
   */
  endpoint: string;
}

//////////
// source: pemloader.go

/**
 * PEMLoader loads certificates and their associated keys by
 * decoding their PEM blocks directly. This has the advantage
 * of not needing to store them on disk at all.
 */
export type PEMLoader = CertKeyPEMPair[];
/**
 * CertKeyPEMPair pairs certificate and key PEM blocks.
 */
export interface CertKeyPEMPair {
  /**
   * The certificate (public key) in PEM format.
   */
  certificate: string;
  /**
   * The private key in PEM format.
   */
  key: string;
  /**
   * Arbitrary values to associate with this certificate.
   * Can be useful when you want to select a particular
   * certificate when there may be multiple valid candidates.
   */
  tags?: string[];
}

//////////
// source: sessiontickets.go

/**
 * SessionTicketService configures and manages TLS session tickets.
 */
export interface SessionTicketService {
  /**
   * KeySource is the method by which Caddy produces or obtains
   * TLS session ticket keys (STEKs). By default, Caddy generates
   * them internally using a secure pseudorandom source.
   */
  key_source?: unknown;
  /**
   * How often Caddy rotates STEKs. Default: 12h.
   */
  rotation_interval?: Duration;
  /**
   * The maximum number of keys to keep in rotation. Default: 4.
   */
  max_keys?: number /* int */;
  /**
   * Disables STEK rotation.
   */
  disable_rotation?: boolean;
  /**
   * Disables TLS session resumption by tickets.
   */
  disabled?: boolean;
}
/**
 * STEKProvider is a type that can provide session ticket ephemeral
 * keys (STEKs).
 */
export type STEKProvider = any;

//////////
// source: storageloader.go

/**
 * StorageLoader loads certificates and their associated keys
 * from the globally configured storage module.
 */
export interface StorageLoader {
  /**
   * A list of pairs of certificate and key file names along with their
   * encoding format so that they can be loaded from storage.
   */
  pairs?: CertKeyFilePair[];
}

//////////
// source: tls.go

/**
 * TLS provides TLS facilities including certificate
 * loading and management, client auth, and more.
 */
export interface TLS {
  /**
   * Certificates to load into memory for quick recall during
   * TLS handshakes. Each key is the name of a certificate
   * loader module.
   * The "automate" certificate loader module can be used to
   * specify a list of subjects that need certificates to be
   * managed automatically, including subdomains that may
   * already be covered by a managed wildcard certificate.
   * The first matching automation policy will be used
   * to manage automated certificate(s).
   * All loaded certificates get pooled
   * into the same cache and may be used to complete TLS
   * handshakes for the relevant server names (SNI).
   * Certificates loaded manually (anything other than
   * "automate") are not automatically managed and will
   * have to be refreshed manually before they expire.
   */
  certificates?: ModuleMap;
  /**
   * Configures certificate automation.
   */
  automation?: AutomationConfig;
  /**
   * Configures session ticket ephemeral keys (STEKs).
   */
  session_tickets?: SessionTicketService;
  /**
   * Configures the in-memory certificate cache.
   */
  cache?: CertCacheOptions;
  /**
   * Disables OCSP stapling for manually-managed certificates only.
   * To configure OCSP stapling for automated certificates, use an
   * automation policy instead.
   * Disabling OCSP stapling puts clients at greater risk, reduces their
   * privacy, and usually lowers client performance. It is NOT recommended
   * to disable this unless you are able to justify the costs.
   * EXPERIMENTAL. Subject to change.
   */
  disable_ocsp_stapling?: boolean;
  /**
   * Disables checks in certmagic that the configured storage is ready
   * and able to handle writing new content to it. These checks are
   * intended to prevent information loss (newly issued certificates), but
   * can be expensive on the storage.
   * Disabling these checks should only be done when the storage
   * can be trusted to have enough capacity and no other problems.
   * EXPERIMENTAL. Subject to change.
   */
  disable_storage_check?: boolean;
  /**
   * Disables the automatic cleanup of the storage backend.
   * This is useful when TLS is not being used to store certificates
   * and the user wants run their server in a read-only mode.
   * Storage cleaning creates two files: instance.uuid and last_clean.json.
   * The instance.uuid file is used to identify the instance of Caddy
   * in a cluster. The last_clean.json file is used to store the last
   * time the storage was cleaned.
   * EXPERIMENTAL. Subject to change.
   */
  disable_storage_clean?: boolean;
  /**
   * Enable Encrypted ClientHello (ECH). ECH protects the server name
   * (SNI) and other sensitive parameters of a normally-plaintext TLS
   * ClientHello during a handshake.
   * EXPERIMENTAL: Subject to change.
   */
  encrypted_client_hello?: ECH;
  /**
   * The default DNS provider module to use when a DNS module is needed.
   * EXPERIMENTAL: Subject to change.
   */
  dns?: unknown;
}
/**
 * CertificateLoader is a type that can load certificates.
 * Certificates can optionally be associated with tags.
 */
export type CertificateLoader = any;
/**
 * Certificate is a TLS certificate, optionally
 * associated with arbitrary tags.
 */
export interface Certificate {
  Certificate: any /* tls.Certificate */;
  Tags: string[];
}
/**
 * AutomateLoader will automatically manage certificates for the names in the
 * list, including obtaining and renewing certificates. Automated certificates
 * are managed according to their matching automation policy, configured
 * elsewhere in this app.
 * Technically, this is a no-op certificate loader module that is treated as
 * a special case: it uses this app's automation features to load certificates
 * for the list of hostnames, rather than loading certificates manually. But
 * the end result is the same: certificates for these subject names will be
 * loaded into the in-memory cache and may then be used.
 */
export type AutomateLoader = string[];
/**
 * CertCacheOptions configures the certificate cache.
 */
export interface CertCacheOptions {
  /**
   * Maximum number of certificates to allow in the
   * cache. If reached, certificates will be randomly
   * evicted to make room for new ones. Default: 10,000
   */
  capacity?: number /* int */;
}

//////////
// source: zerosslissuer.go

/**
 * ZeroSSLIssuer uses the ZeroSSL API to get certificates.
 * Note that this is distinct from ZeroSSL's ACME endpoint.
 * To use ZeroSSL's ACME endpoint, use the ACMEIssuer
 * configured with ZeroSSL's ACME directory endpoint.
 */
export interface ZeroSSLIssuer {
  /**
   * The API key (or "access key") for using the ZeroSSL API.
   * REQUIRED.
   */
  api_key?: string;
  /**
   * How many days the certificate should be valid for.
   * Only certain values are accepted; see ZeroSSL docs.
   */
  validity_days?: number /* int */;
  /**
   * The host to bind to when opening a listener for
   * verifying domain names (or IPs).
   */
  listen_host?: string;
  /**
   * If HTTP is forwarded from port 80, specify the
   * forwarded port here.
   */
  alternate_http_port?: number /* int */;
  /**
   * Use CNAME validation instead of HTTP. ZeroSSL's
   * API uses CNAME records for DNS validation, similar
   * to how Let's Encrypt uses TXT records for the
   * DNS challenge.
   */
  cname_validation?: DNSChallengeConfig;
}
