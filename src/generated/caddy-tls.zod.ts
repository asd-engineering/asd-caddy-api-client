// Generated by ts-to-zod
import { z } from "zod";
import { type Certificate } from "./caddy-tls";

export const chainPreferenceSchema = z.object({
  smallest: z.boolean().optional(),
  root_common_name: z.array(z.string()).optional(),
  any_common_name: z.array(z.string()).optional(),
});

export const automationPolicySchema = z.object({
  subjects: z.array(z.string()).optional(),
  issuers: z.array(z.unknown()).optional(),
  get_certificate: z.array(z.unknown()).optional(),
  must_staple: z.boolean().optional(),
  renewal_window_ratio: z.number().optional(),
  key_type: z.string().optional(),
  storage: z.unknown().optional(),
  on_demand: z.boolean().optional(),
  reuse_private_keys: z.boolean().optional(),
  disable_ocsp_stapling: z.boolean().optional(),
  ocsp_overrides: z.record(z.string(), z.string()).optional(),
});

export const onDemandConfigSchema = z.object({
  ask: z.string().optional(),
  permission: z.unknown().optional(),
});

export const httpChallengeConfigSchema = z.object({
  disabled: z.boolean().optional(),
  alternate_port: z.number().optional(),
});

export const tlsalpnChallengeConfigSchema = z.object({
  disabled: z.boolean().optional(),
  alternate_port: z.number().optional(),
});

export const configSetterSchema = z.any();

export const caSchema = z.any();

export const inlineCaPoolSchema = z.object({
  trusted_ca_certs: z.array(z.string()).optional(),
});

export const fileCaPoolSchema = z.object({
  pem_files: z.array(z.string()).optional(),
});

export const pkiRootCaPoolSchema = z.object({
  authority: z.array(z.string()).optional(),
});

export const pkiIntermediateCaPoolSchema = z.object({
  authority: z.array(z.string()).optional(),
});

export const storagePoolSchema = z.object({
  storage: z.unknown().optional(),
  pem_keys: z.array(z.string()).optional(),
});

export const tailscaleSchema = z.object({});

export const httpCertGetterSchema = z.object({
  url: z.string().optional(),
});

export const publicKeyAlgorithmSchema = z.number();

export const customCertSelectionPolicySchema = z.object({
  serial_number: z.array(z.string()).optional(),
  subject_organization: z.array(z.string()).optional(),
  public_key_algorithm: publicKeyAlgorithmSchema.optional(),
  any_tag: z.array(z.string()).optional(),
  all_tags: z.array(z.string()).optional(),
});

export const clientAuthenticationSchema = z.object({
  ca: z.unknown().optional(),
  trusted_ca_certs: z.array(z.string()).optional(),
  trusted_ca_certs_pem_files: z.array(z.string()).optional(),
  trusted_leaf_certs: z.array(z.string()).optional(),
  verifiers: z.array(z.unknown()).optional(),
  mode: z.string().optional(),
});

export const handshakeContextSchema = z.any();

export const leafCertClientAuthSchema = z.object({
  leaf_certs_loaders: z.array(z.unknown()).optional(),
});

export const connectionMatcherSchema = z.any();

export const leafCertificateLoaderSchema = z.any();

export const clientCertificateVerifierSchema = z.any();

export const echConfigurationSchema = z.object({
  public_name: z.string(),
});

export const echdnsProviderSchema = z.unknown().and(z.unknown());

export const echdnsPublisherSchema = z.object({
  provider: z.unknown().optional(),
});

export const echPublisherSchema = z.any();

export const certKeyFilePairSchema = z.object({
  certificate: z.string(),
  key: z.string(),
  format: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

export const folderLoaderSchema = z.array(z.string());

export const leafFileLoaderSchema = z.object({
  files: z.array(z.string()).optional(),
});

export const leafFolderLoaderSchema = z.object({
  folders: z.array(z.string()).optional(),
});

export const leafPemLoaderSchema = z.object({
  certificates: z.array(z.string()).optional(),
});

export const leafStorageLoaderSchema = z.object({
  certificates: z.array(z.string()).optional(),
  storage: z.unknown().optional(),
});

export const matchServerNameSchema = z.array(z.string());

export const matchRegexpSchema = z.object({
  name: z.string().optional(),
  pattern: z.string(),
});

export const matchServerNameReSchema = z.object({
  MatchRegexp: matchRegexpSchema,
});

export const matchRemoteIpSchema = z.object({
  ranges: z.array(z.string()).optional(),
  not_ranges: z.array(z.string()).optional(),
});

export const matchLocalIpSchema = z.object({
  ranges: z.array(z.string()).optional(),
});

export const onDemandPermissionSchema = z.any();

export const permissionByHttpSchema = z.object({
  endpoint: z.string(),
});

export const certKeyPemPairSchema = z.object({
  certificate: z.string(),
  key: z.string(),
  tags: z.array(z.string()).optional(),
});

export const stekProviderSchema = z.any();

export const storageLoaderSchema = z.object({
  pairs: z.array(certKeyFilePairSchema).optional(),
});

export const certCacheOptionsSchema = z.object({
  capacity: z.number().optional(),
});

export const certificateLoaderSchema = z.any();

export const certificateSchema: z.ZodSchema<Certificate> = z.lazy(() =>
  z.object({
    Certificate: certificateSchema,
    Tags: z.array(z.string()),
  })
);

export const automateLoaderSchema = z.array(z.string());

const durationSchema = z.any();

const moduleMapSchema = z.any();

export const automationConfigSchema = z.object({
  policies: z.array(z.union([automationPolicySchema, z.undefined()])).optional(),
  on_demand: onDemandConfigSchema.optional(),
  ocsp_interval: durationSchema.optional(),
  renew_interval: durationSchema.optional(),
  storage_clean_interval: durationSchema.optional(),
});

export const dnsChallengeConfigSchema = z.object({
  provider: z.unknown().optional(),
  ttl: durationSchema.optional(),
  propagation_delay: durationSchema.optional(),
  propagation_timeout: durationSchema.optional(),
  resolvers: z.array(z.string()).optional(),
  override_domain: z.string().optional(),
});

export const tlsConfigSchema = z.object({
  ca: z.unknown().optional(),
  insecure_skip_verify: z.boolean().optional(),
  handshake_timeout: durationSchema.optional(),
  server_name: z.string().optional(),
  renegotiation: z.string().optional(),
});

export const httpCertPoolSchema = z.object({
  endpoints: z.array(z.string()).optional(),
  tls: tlsConfigSchema.optional(),
});

export const connectionPolicySchema = z.object({
  match: moduleMapSchema.optional(),
  certificate_selection: customCertSelectionPolicySchema.optional(),
  cipher_suites: z.array(z.string()).optional(),
  curves: z.array(z.string()).optional(),
  alpn: z.array(z.string()).optional(),
  protocol_min: z.string().optional(),
  protocol_max: z.string().optional(),
  drop: z.boolean().optional(),
  client_authentication: clientAuthenticationSchema.optional(),
  default_sni: z.string().optional(),
  fallback_sni: z.string().optional(),
  insecure_secrets_log: z.string().optional(),
  handshake_context: z.unknown().optional(),
});

export const echPublicationSchema = z.object({
  configs: z.array(z.string()).optional(),
  domains: z.array(z.string()).optional(),
  publishers: moduleMapSchema.optional(),
});

export const fileLoaderSchema = z.array(certKeyFilePairSchema);

export const internalIssuerSchema = z.object({
  ca: z.string().optional(),
  lifetime: durationSchema.optional(),
  sign_with_root: z.boolean().optional(),
});

export const pemLoaderSchema = z.array(certKeyPemPairSchema);

export const sessionTicketServiceSchema = z.object({
  key_source: z.unknown().optional(),
  rotation_interval: durationSchema.optional(),
  max_keys: z.number().optional(),
  disable_rotation: z.boolean().optional(),
  disabled: z.boolean().optional(),
});

export const echSchema = z.object({
  configs: z.array(echConfigurationSchema).optional(),
  publication: z.array(z.union([echPublicationSchema, z.undefined()])).optional(),
});

export const zeroSslIssuerSchema = z.object({
  api_key: z.string().optional(),
  validity_days: z.number().optional(),
  listen_host: z.string().optional(),
  alternate_http_port: z.number().optional(),
  cname_validation: dnsChallengeConfigSchema.optional(),
});

export const challengesConfigSchema = z.object({
  http: httpChallengeConfigSchema.optional(),
  "tls-alpn": tlsalpnChallengeConfigSchema.optional(),
  dns: dnsChallengeConfigSchema.optional(),
  bind_host: z.string().optional(),
  distributed: z.boolean().optional(),
});

export const connectionPoliciesSchema = z.array(z.union([connectionPolicySchema, z.undefined()]));

export const tlsSchema = z.object({
  certificates: moduleMapSchema.optional(),
  automation: automationConfigSchema.optional(),
  session_tickets: sessionTicketServiceSchema.optional(),
  cache: certCacheOptionsSchema.optional(),
  disable_ocsp_stapling: z.boolean().optional(),
  disable_storage_check: z.boolean().optional(),
  disable_storage_clean: z.boolean().optional(),
  encrypted_client_hello: echSchema.optional(),
  dns: z.unknown().optional(),
});

export const acmeIssuerSchema = z.object({
  ca: z.string().optional(),
  test_ca: z.string().optional(),
  email: z.string().optional(),
  profile: z.string().optional(),
  account_key: z.string().optional(),
  external_account: z
    .object({
      kid: z.string().optional(),
      hmacEncoded: z.string().optional(),
    })
    .optional(),
  acme_timeout: durationSchema.optional(),
  challenges: challengesConfigSchema.optional(),
  trusted_roots_pem_files: z.array(z.string()).optional(),
  preferred_chains: chainPreferenceSchema.optional(),
  certificate_lifetime: durationSchema.optional(),
  network_proxy: z.unknown().optional(),
});
